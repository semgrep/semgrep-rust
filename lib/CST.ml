(* Generated by ocaml-tree-sitter. *)
(*
   rust grammar

   entrypoint: source_file
*)

open! Sexplib.Conv
open Tree_sitter_run

type imm_tok_dquot = Token.t (* "\"" *)

type shebang = Token.t (* pattern #![\s]*[^\[\s]+ *)

type block_comment = Token.t

type line_comment_explicit = unit (* blank *)

type tok_prec_p1_lt = Token.t

type anon_choice_PLUS_348fa54 = [
    `PLUS of Token.t (* "+" *)
  | `STAR of Token.t (* "*" *)
  | `QMARK of Token.t (* "?" *)
]

type anon_choice_u8_6dad923 = [
    `U8 of Token.t (* "u8" *)
  | `I8 of Token.t (* "i8" *)
  | `U16 of Token.t (* "u16" *)
  | `I16 of Token.t (* "i16" *)
  | `U32 of Token.t (* "u32" *)
  | `I32 of Token.t (* "i32" *)
  | `U64 of Token.t (* "u64" *)
  | `I64 of Token.t (* "i64" *)
  | `U128 of Token.t (* "u128" *)
  | `I128 of Token.t (* "i128" *)
  | `Isize of Token.t (* "isize" *)
  | `Usize of Token.t (* "usize" *)
  | `F32 of Token.t (* "f32" *)
  | `F64 of Token.t (* "f64" *)
  | `Bool of Token.t (* "bool" *)
  | `Str of Token.t (* "str" *)
  | `Char of Token.t (* "char" *)
]

type identifier = Token.t

type integer_literal = Token.t

type string_content = Token.t

type escape_sequence = Token.t

type pat_1e84e62 = Token.t (* pattern [^+*?]+ *)

type boolean_literal = [
    `True of Token.t (* "true" *)
  | `False of Token.t (* "false" *)
]

type fragment_specifier = [
    `Blk of Token.t (* "block" *)
  | `Expr of Token.t (* "expr" *)
  | `Id of Token.t (* "ident" *)
  | `Item of Token.t (* "item" *)
  | `Life of Token.t (* "lifetime" *)
  | `Lit of Token.t (* "literal" *)
  | `Meta of Token.t (* "meta" *)
  | `Pat of Token.t (* "pat" *)
  | `Path of Token.t (* "path" *)
  | `Stmt of Token.t (* "stmt" *)
  | `Tt of Token.t (* "tt" *)
  | `Ty of Token.t (* "ty" *)
  | `Vis of Token.t (* "vis" *)
]

type reserved_identifier = [
    `Defa of Token.t (* "default" *)
  | `Union of Token.t (* "union" *)
]

type block_comment_explicit = unit (* blank *)

type pat_eeda0f5 = Token.t (* pattern "[bc]?\"" *)

type raw_string_literal = Token.t

type char_literal = Token.t

type metavariable = Token.t (* pattern \$[a-zA-Z_]\w* *)

type line_comment = Token.t

type float_literal = Token.t

type string_literal = (
    pat_eeda0f5
  * [
        `Esc_seq of escape_sequence (*tok*)
      | `Str_content of string_content (*tok*)
    ]
      list (* zero or more *)
  * imm_tok_dquot (*tok*)
)

type label = (Token.t (* "'" *) * identifier (*tok*))

type lifetime = (Token.t (* "'" *) * identifier (*tok*))

type anon_choice_type_id_8184947 = [
    `Id of identifier (*tok*)
  | `Meta of metavariable (*tok*)
]

type extern_modifier = (Token.t (* "extern" *) * string_literal option)

type literal = [
    `Str_lit of string_literal
  | `Raw_str_lit of raw_string_literal (*tok*)
  | `Char_lit of char_literal (*tok*)
  | `Bool_lit of boolean_literal
  | `Int_lit of integer_literal (*tok*)
  | `Float_lit of float_literal (*tok*)
]

type literal_pattern = [
    `Str_lit of string_literal
  | `Raw_str_lit of raw_string_literal (*tok*)
  | `Char_lit of char_literal (*tok*)
  | `Bool_lit of boolean_literal
  | `Int_lit of integer_literal (*tok*)
  | `Float_lit of float_literal (*tok*)
  | `Nega_lit of (
        Token.t (* "-" *)
      * [
            `Int_lit of integer_literal (*tok*)
          | `Float_lit of float_literal (*tok*)
        ]
    )
]

type for_lifetimes = (
    Token.t (* "for" *)
  * Token.t (* "<" *)
  * lifetime
  * (Token.t (* "," *) * lifetime) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* ">" *)
)

type function_modifiers =
  [
      `Async of Token.t (* "async" *)
    | `Defa of Token.t (* "default" *)
    | `Const of Token.t (* "const" *)
    | `Unsafe of Token.t (* "unsafe" *)
    | `Extern_modi of extern_modifier
  ]
    list (* one or more *)

type non_special_token = [
    `Choice_lit of [
        `Lit of literal
      | `Id of identifier (*tok*)
      | `Muta_spec of Token.t (* "mut" *)
      | `Self of Token.t (* "self" *)
      | `Super of Token.t (* "super" *)
      | `Crate of Token.t (* "crate" *)
      | `Choice_u8 of anon_choice_u8_6dad923
      | `Rep1_choice_SLASH of
          [
              `SLASH of Token.t (* "/" *)
            | `X__ of Token.t (* "_" *)
            | `BSLASH of Token.t (* "\\" *)
            | `DASH of Token.t (* "-" *)
            | `EQ of Token.t (* "=" *)
            | `DASHGT of Token.t (* "->" *)
            | `COMMA of Token.t (* "," *)
            | `SEMI of Token.t (* ";" *)
            | `COLON of Token.t (* ":" *)
            | `COLONCOLON of Token.t (* "::" *)
            | `BANG of Token.t (* "!" *)
            | `QMARK of Token.t (* "?" *)
            | `DOT of Token.t (* "." *)
            | `AT of Token.t (* "@" *)
            | `STAR of Token.t (* "*" *)
            | `AMP of Token.t (* "&" *)
            | `HASH of Token.t (* "#" *)
            | `PERC of Token.t (* "%" *)
            | `HAT of Token.t (* "^" *)
            | `PLUS of Token.t (* "+" *)
            | `LT of Token.t (* "<" *)
            | `GT of Token.t (* ">" *)
            | `BAR of Token.t (* "|" *)
            | `TILDE of Token.t (* "~" *)
          ]
            list (* one or more *)
      | `SQUOT of Token.t (* "'" *)
      | `As of Token.t (* "as" *)
      | `Async of Token.t (* "async" *)
      | `Await of Token.t (* "await" *)
      | `Brk of Token.t (* "break" *)
      | `Const of Token.t (* "const" *)
      | `Cont of Token.t (* "continue" *)
      | `Defa of Token.t (* "default" *)
      | `Enum of Token.t (* "enum" *)
      | `Fn of Token.t (* "fn" *)
      | `For of Token.t (* "for" *)
      | `If of Token.t (* "if" *)
      | `Impl of Token.t (* "impl" *)
      | `Let of Token.t (* "let" *)
      | `Loop of Token.t (* "loop" *)
      | `Match of Token.t (* "match" *)
      | `Mod of Token.t (* "mod" *)
      | `Pub of Token.t (* "pub" *)
      | `Ret of Token.t (* "return" *)
      | `Static of Token.t (* "static" *)
      | `Struct of Token.t (* "struct" *)
      | `Trait of Token.t (* "trait" *)
      | `Type of Token.t (* "type" *)
      | `Union of Token.t (* "union" *)
      | `Unsafe of Token.t (* "unsafe" *)
      | `Use of Token.t (* "use" *)
      | `Where of Token.t (* "where" *)
      | `While of Token.t (* "while" *)
    ]
  | `Ellips of Token.t (* "..." *)
]

type token_pattern = [
    `Tok_tree_pat of token_tree_pattern
  | `Tok_repe_pat of (
        Token.t (* "$" *)
      * Token.t (* "(" *)
      * token_pattern list (* zero or more *)
      * Token.t (* ")" *)
      * pat_1e84e62 option
      * anon_choice_PLUS_348fa54
    )
  | `Tok_bind_pat of (
        metavariable (*tok*) * Token.t (* ":" *) * fragment_specifier
    )
  | `Meta of metavariable (*tok*)
  | `Choice_choice_lit of non_special_token
]

and token_tree_pattern = [
    `LPAR_rep_tok_pat_RPAR of (
        Token.t (* "(" *)
      * token_pattern list (* zero or more *)
      * Token.t (* ")" *)
    )
  | `LBRACK_rep_tok_pat_RBRACK of (
        Token.t (* "[" *)
      * token_pattern list (* zero or more *)
      * Token.t (* "]" *)
    )
  | `LCURL_rep_tok_pat_RCURL of (
        Token.t (* "{" *)
      * token_pattern list (* zero or more *)
      * Token.t (* "}" *)
    )
]

type token_tree = [
    `LPAR_rep_choice_tok_tree_RPAR of (
        Token.t (* "(" *)
      * tokens list (* zero or more *)
      * Token.t (* ")" *)
    )
  | `LBRACK_rep_choice_tok_tree_RBRACK of (
        Token.t (* "[" *)
      * tokens list (* zero or more *)
      * Token.t (* "]" *)
    )
  | `LCURL_rep_choice_tok_tree_RCURL of (
        Token.t (* "{" *)
      * tokens list (* zero or more *)
      * Token.t (* "}" *)
    )
]

and tokens = [
    `Tok_tree of token_tree
  | `Tok_repe of (
        Token.t (* "$" *)
      * Token.t (* "(" *)
      * tokens list (* zero or more *)
      * Token.t (* ")" *)
      * pat_1e84e62 option
      * anon_choice_PLUS_348fa54
    )
  | `Meta of metavariable (*tok*)
  | `Choice_choice_lit of non_special_token
]

type non_delim_token = [
    `Choice_choice_lit of non_special_token
  | `DOLLAR of Token.t (* "$" *)
]

type macro_rule = (token_tree_pattern * Token.t (* "=>" *) * token_tree)

type delim_token_tree = [
    `LPAR_rep_delim_tokens_RPAR of (
        Token.t (* "(" *)
      * delim_tokens list (* zero or more *)
      * Token.t (* ")" *)
    )
  | `LBRACK_rep_delim_tokens_RBRACK of (
        Token.t (* "[" *)
      * delim_tokens list (* zero or more *)
      * Token.t (* "]" *)
    )
  | `LCURL_rep_delim_tokens_RCURL of (
        Token.t (* "{" *)
      * delim_tokens list (* zero or more *)
      * Token.t (* "}" *)
    )
]

and delim_tokens = [
    `Non_delim_tok of non_delim_token
  | `Delim_tok_tree of delim_token_tree
]

type macro_definition = (
    Token.t (* "macro_rules!" *)
  * [ `Id of identifier (*tok*) | `Choice_defa of reserved_identifier ]
  * [
        `LPAR_rep_macro_rule_SEMI_opt_macro_rule_RPAR_SEMI of (
            Token.t (* "(" *)
          * (macro_rule * Token.t (* ";" *)) list (* zero or more *)
          * macro_rule option
          * Token.t (* ")" *)
          * Token.t (* ";" *)
        )
      | `LCURL_rep_macro_rule_SEMI_opt_macro_rule_RCURL of (
            Token.t (* "{" *)
          * (macro_rule * Token.t (* ";" *)) list (* zero or more *)
          * macro_rule option
          * Token.t (* "}" *)
        )
    ]
)

type anon_choice_SEMI_226cc40 = [
    `SEMI of Token.t (* ";" *)
  | `Decl_list of declaration_list
]

and anon_choice_field_pat_8e757e8 = [
    `Field_pat of (
        Token.t (* "ref" *) option
      * Token.t (* "mut" *) option
      * [
            `Id of identifier (*tok*)
          | `Id_COLON_pat of (
                identifier (*tok*) * Token.t (* ":" *) * pattern
            )
        ]
    )
  | `Rema_field_pat of Token.t (* ".." *)
]

and anon_choice_life_859e88f = [
    `Life of lifetime
  | `Meta of metavariable (*tok*)
  | `Id of identifier (*tok*)
  | `Cons_type_param of constrained_type_parameter
  | `Opt_type_param of (
        [
            `Id of identifier (*tok*)
          | `Cons_type_param of constrained_type_parameter
        ]
      * Token.t (* "=" *)
      * type_
    )
  | `Const_param of (
        Token.t (* "const" *) * identifier (*tok*) * Token.t (* ":" *)
      * type_
    )
]

and anon_choice_lit_pat_0884ef0 = [
    `Lit_pat of literal_pattern
  | `Choice_self of path
]

and anon_choice_param_2c23cdc = [
    `Param of parameter
  | `Self_param of (
        Token.t (* "&" *) option
      * lifetime option
      * Token.t (* "mut" *) option
      * Token.t (* "self" *)
    )
  | `Vari_param of Token.t (* "..." *)
  | `X__ of Token.t (* "_" *)
  | `Type of type_
]

and anon_choice_pat_17a3e23 = [
    `Pat of pattern
  | `Clos_exp of closure_expression
]

and anon_choice_pat_4717dcc = [ `Pat of pattern | `Param of parameter ]

and anon_choice_shor_field_init_9cb4441 = [
    `Shor_field_init of (
        attribute_item list (* zero or more *)
      * identifier (*tok*)
    )
  | `Field_init of (
        attribute_item list (* zero or more *)
      * identifier (*tok*)
      * Token.t (* ":" *)
      * expression
    )
  | `Base_field_init of base_field_initializer
]

and anon_choice_type_39799c3 = [
    `Type of type_
  | `Type_bind of (
        identifier (*tok*)
      * type_arguments option
      * Token.t (* "=" *)
      * type_
    )
  | `Life of lifetime
  | `Lit of literal
  | `Blk of block
]

and anon_choice_type_d689819 = [
    `Type of type_
  | `Life of lifetime
  | `Higher_ranked_trait_bound of higher_ranked_trait_bound
  | `Remo_trait_bound of (Token.t (* "?" *) * type_)
]

and anon_choice_type_id_02b4436 = [
    `Id of identifier (*tok*)
  | `Scoped_type_id of scoped_type_identifier
  | `Gene_type of generic_type
  | `Func_type of function_type
]

and anon_choice_type_id_2c46bcf = [
    `Id of identifier (*tok*)
  | `Scoped_type_id of scoped_type_identifier
]

and anon_choice_type_id_f1f5a37 = [
    `Id of identifier (*tok*)
  | `Scoped_id of scoped_identifier
]

and anon_opt_rep_attr_item_exp_rep_COMMA_rep_attr_item_exp_3d9e0d4 =
  (
      attribute_item list (* zero or more *)
    * expression
    * anon_rep_COMMA_rep_attr_item_exp_f504d6c
  )
    option

and anon_pat_rep_COMMA_pat_2a80f16 = (
    pattern
  * (Token.t (* "," *) * pattern) list (* zero or more *)
)

and anon_rep_COMMA_rep_attr_item_exp_f504d6c =
  (Token.t (* "," *) * attribute_item list (* zero or more *) * expression)
    list (* zero or more *)

and arguments = (
    Token.t (* "(" *)
  * anon_opt_rep_attr_item_exp_rep_COMMA_rep_attr_item_exp_3d9e0d4
  * Token.t (* "," *) option
  * Token.t (* ")" *)
)

and array_type = (
    Token.t (* "[" *)
  * type_
  * (Token.t (* ";" *) * expression) option
  * Token.t (* "]" *)
)

and associated_type = (
    Token.t (* "type" *)
  * identifier (*tok*)
  * type_parameters option
  * trait_bounds option
  * Token.t (* ";" *)
)

and attribute = (
    path
  * [
        `EQ_exp of (Token.t (* "=" *) * expression)
      | `Delim_tok_tree of delim_token_tree
    ]
      option
)

and attribute_item = (
    Token.t (* "#" *) * Token.t (* "[" *) * attribute * Token.t (* "]" *)
)

and base_field_initializer = (Token.t (* ".." *) * expression)

and binary_expression = [
    `Exp_AMPAMP_exp of (expression * Token.t (* "&&" *) * expression)
  | `Exp_BARBAR_exp of (expression * Token.t (* "||" *) * expression)
  | `Exp_AMP_exp of (expression * Token.t (* "&" *) * expression)
  | `Exp_BAR_exp of (expression * Token.t (* "|" *) * expression)
  | `Exp_HAT_exp of (expression * Token.t (* "^" *) * expression)
  | `Exp_choice_EQEQ_exp of (
        expression
      * [
            `EQEQ of Token.t (* "==" *)
          | `BANGEQ of Token.t (* "!=" *)
          | `LT of Token.t (* "<" *)
          | `LTEQ of Token.t (* "<=" *)
          | `GT of Token.t (* ">" *)
          | `GTEQ of Token.t (* ">=" *)
        ]
      * expression
    )
  | `Exp_choice_LTLT_exp of (
        expression
      * [ `LTLT of Token.t (* "<<" *) | `GTGT of Token.t (* ">>" *) ]
      * expression
    )
  | `Exp_choice_PLUS_exp of (
        expression
      * [ `PLUS of Token.t (* "+" *) | `DASH of Token.t (* "-" *) ]
      * expression
    )
  | `Exp_choice_STAR_exp of (
        expression
      * [
            `STAR of Token.t (* "*" *)
          | `SLASH of Token.t (* "/" *)
          | `PERC of Token.t (* "%" *)
        ]
      * expression
    )
]

and block = (
    (label * Token.t (* ":" *)) option
  * Token.t (* "{" *)
  * statement list (* zero or more *)
  * expression option
  * Token.t (* "}" *)
)

and bounded_type = [
    `Life_PLUS_type of (lifetime * Token.t (* "+" *) * type_)
  | `Type_PLUS_type of (type_ * Token.t (* "+" *) * type_)
  | `Type_PLUS_life of (type_ * Token.t (* "+" *) * lifetime)
]

and bracketed_type = (
    Token.t (* "<" *)
  * [ `Type of type_ | `Qual_type of qualified_type ]
  * Token.t (* ">" *)
)

and closure_expression = (
    Token.t (* "static" *) option
  * Token.t (* "move" *) option
  * closure_parameters
  * [
        `Opt_DASHGT_type_blk of ((Token.t (* "->" *) * type_) option * block)
      | `Choice_exp of [ `Exp of expression | `X__ of Token.t (* "_" *) ]
    ]
)

and closure_parameters = (
    Token.t (* "|" *)
  * (
        anon_choice_pat_4717dcc
      * (Token.t (* "," *) * anon_choice_pat_4717dcc) list (* zero or more *)
    )
      option
  * Token.t (* "|" *)
)

and condition = [
    `Exp of expression
  | `Let_cond of let_condition
  | `Let_chain of let_chain
]

and const_block = (Token.t (* "const" *) * block)

and const_item = (
    visibility_modifier option
  * Token.t (* "const" *)
  * identifier (*tok*)
  * Token.t (* ":" *)
  * type_
  * (Token.t (* "=" *) * expression) option
  * Token.t (* ";" *)
)

and constrained_type_parameter = (
    [ `Life of lifetime | `Id of identifier (*tok*) ]
  * trait_bounds
)

and declaration_list = (
    Token.t (* "{" *)
  * declaration_statement list (* zero or more *)
  * Token.t (* "}" *)
)

and declaration_statement = [
    `Choice_const_item of [
        `Const_item of const_item
      | `Macro_invo of macro_invocation
      | `Macro_defi of macro_definition
      | `Empty_stmt of Token.t (* ";" *)
      | `Attr_item of attribute_item
      | `Inner_attr_item of inner_attribute_item
      | `Mod_item of mod_item
      | `Fore_mod_item of foreign_mod_item
      | `Struct_item of struct_item
      | `Union_item of union_item
      | `Enum_item of enum_item
      | `Type_item of type_item
      | `Func_item of function_item
      | `Func_sign_item of function_signature_item
      | `Impl_item of impl_item
      | `Trait_item of trait_item
      | `Asso_type of associated_type
      | `Let_decl of let_declaration
      | `Use_decl of use_declaration
      | `Extern_crate_decl of extern_crate_declaration
      | `Static_item of static_item
    ]
  | `Ellips of Token.t (* "..." *)
]

and else_clause = (
    Token.t (* "else" *)
  * [ `Blk of block | `If_exp of if_expression ]
)

and enum_item = (
    visibility_modifier option
  * Token.t (* "enum" *)
  * identifier (*tok*)
  * type_parameters option
  * where_clause option
  * enum_variant_list
)

and enum_variant = (
    visibility_modifier option
  * identifier (*tok*)
  * [
        `Field_decl_list of field_declaration_list
      | `Orde_field_decl_list of ordered_field_declaration_list
    ]
      option
  * (Token.t (* "=" *) * expression) option
)

and enum_variant_list = (
    Token.t (* "{" *)
  * (
        attribute_item list (* zero or more *)
      * enum_variant
      * (
            Token.t (* "," *)
          * attribute_item list (* zero or more *)
          * enum_variant
        )
          list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)

and expression = [
    `Exp_except_range of expression_except_range
  | `Range_exp of range_expression
  | `Ellips of Token.t (* "..." *)
  | `Deep_ellips of (
        Token.t (* "<..." *) * expression * Token.t (* "...>" *)
    )
  | `Member_access_ellips_exp of (
        expression * Token.t (* "." *) * Token.t (* "..." *)
    )
]

and expression_ending_with_block = [
    `Unsafe_blk of (Token.t (* "unsafe" *) * block)
  | `Async_blk of (
        Token.t (* "async" *)
      * Token.t (* "move" *) option
      * block
    )
  | `Try_blk of (Token.t (* "try" *) * block)
  | `Blk of block
  | `If_exp of if_expression
  | `Match_exp of (Token.t (* "match" *) * expression * match_block)
  | `While_exp of (
        (label * Token.t (* ":" *)) option
      * Token.t (* "while" *)
      * condition
      * block
    )
  | `Loop_exp of (
        (label * Token.t (* ":" *)) option
      * Token.t (* "loop" *)
      * block
    )
  | `For_exp of (
        (label * Token.t (* ":" *)) option
      * Token.t (* "for" *)
      * pattern
      * Token.t (* "in" *)
      * expression
      * block
    )
  | `Const_blk of const_block
]

and expression_except_range = [
    `Un_exp of (
        [
            `DASH of Token.t (* "-" *)
          | `STAR of Token.t (* "*" *)
          | `BANG of Token.t (* "!" *)
        ]
      * expression
    )
  | `Ref_exp of (Token.t (* "&" *) * Token.t (* "mut" *) option * expression)
  | `Try_exp of (expression * Token.t (* "?" *))
  | `Bin_exp of binary_expression
  | `Assign_exp of (expression * Token.t (* "=" *) * expression)
  | `Comp_assign_expr of (
        expression
      * [
            `PLUSEQ of Token.t (* "+=" *)
          | `DASHEQ of Token.t (* "-=" *)
          | `STAREQ of Token.t (* "*=" *)
          | `SLASHEQ of Token.t (* "/=" *)
          | `PERCEQ of Token.t (* "%=" *)
          | `AMPEQ of Token.t (* "&=" *)
          | `BAREQ of Token.t (* "|=" *)
          | `HATEQ of Token.t (* "^=" *)
          | `LTLTEQ of Token.t (* "<<=" *)
          | `GTGTEQ of Token.t (* ">>=" *)
        ]
      * expression
    )
  | `Type_cast_exp of (expression * Token.t (* "as" *) * type_)
  | `Call_exp of (expression_except_range * arguments)
  | `Ret_exp of return_expression
  | `Yield_exp of yield_expression
  | `Lit of literal
  | `Id of identifier (*tok*)
  | `Choice_u8 of anon_choice_u8_6dad923
  | `Choice_defa of reserved_identifier
  | `Self of Token.t (* "self" *)
  | `Scoped_id of scoped_identifier
  | `Gene_func of (
        [
            `Id of identifier (*tok*)
          | `Scoped_id of scoped_identifier
          | `Field_exp of field_expression
        ]
      * Token.t (* "::" *)
      * type_arguments
    )
  | `Await_exp of (expression * Token.t (* "." *) * Token.t (* "await" *))
  | `Field_exp of field_expression
  | `Array_exp of (
        Token.t (* "[" *)
      * attribute_item list (* zero or more *)
      * [
            `Exp_SEMI_exp of (expression * Token.t (* ";" *) * expression)
          | `Opt_rep_attr_item_exp_rep_COMMA_rep_attr_item_exp_opt_COMMA of (
                anon_opt_rep_attr_item_exp_rep_COMMA_rep_attr_item_exp_3d9e0d4
              * Token.t (* "," *) option
            )
        ]
      * Token.t (* "]" *)
    )
  | `Tuple_exp of (
        Token.t (* "(" *)
      * attribute_item list (* zero or more *)
      * expression
      * Token.t (* "," *)
      * (expression * Token.t (* "," *)) list (* zero or more *)
      * expression option
      * Token.t (* ")" *)
    )
  | `Macro_invo of macro_invocation
  | `Unit_exp of (Token.t (* "(" *) * Token.t (* ")" *))
  | `Brk_exp of (Token.t (* "break" *) * label option * expression option)
  | `Cont_exp of (Token.t (* "continue" *) * label option)
  | `Index_exp of (
        expression * Token.t (* "[" *) * expression * Token.t (* "]" *)
    )
  | `Meta of metavariable (*tok*)
  | `Clos_exp of closure_expression
  | `Paren_exp of (
        Token.t (* "(" *)
      * [ `Exp of expression | `Semg_typed_meta of semgrep_typed_metavar ]
      * Token.t (* ")" *)
    )
  | `Struct_exp of (
        [
            `Id of identifier (*tok*)
          | `Scoped_type_id_in_exp_posi of
              scoped_type_identifier_in_expression_position
          | `Gene_type_with_turb of generic_type_with_turbofish
        ]
      * field_initializer_list
    )
  | `Choice_unsafe_blk of expression_ending_with_block
]

and expression_statement = [
    `Choice_exp_SEMI of [
        `Exp_SEMI of (expression * Token.t (* ";" *))
      | `Choice_unsafe_blk of expression_ending_with_block
    ]
  | `Ellips_SEMI of (Token.t (* "..." *) * Token.t (* ";" *))
  | `Ellips of Token.t (* "..." *)
]

and extern_crate_declaration = (
    visibility_modifier option
  * Token.t (* "extern" *)
  * Token.t (* "crate" *)
  * identifier (*tok*)
  * (Token.t (* "as" *) * identifier (*tok*)) option
  * Token.t (* ";" *)
)

and field_declaration = [
    `Opt_visi_modi_id_COLON_type of (
        visibility_modifier option
      * identifier (*tok*)
      * Token.t (* ":" *)
      * type_
    )
  | `Ellips of Token.t (* "..." *)
]

and field_declaration_list = (
    Token.t (* "{" *)
  * (
        attribute_item list (* zero or more *)
      * field_declaration
      * (
            Token.t (* "," *)
          * attribute_item list (* zero or more *)
          * field_declaration
        )
          list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)

and field_expression = (
    expression
  * Token.t (* "." *)
  * [ `Id of identifier (*tok*) | `Int_lit of integer_literal (*tok*) ]
)

and field_initializer_list = (
    Token.t (* "{" *)
  * (
        anon_choice_shor_field_init_9cb4441
      * (Token.t (* "," *) * anon_choice_shor_field_init_9cb4441)
          list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)

and foreign_mod_item = (
    visibility_modifier option
  * extern_modifier
  * anon_choice_SEMI_226cc40
)

and function_item = (
    visibility_modifier option
  * function_modifiers option
  * Token.t (* "fn" *)
  * anon_choice_type_id_8184947
  * type_parameters option
  * parameters
  * (Token.t (* "->" *) * type_) option
  * where_clause option
  * block
)

and function_signature_item = (
    visibility_modifier option
  * function_modifiers option
  * Token.t (* "fn" *)
  * anon_choice_type_id_8184947
  * type_parameters option
  * parameters
  * (Token.t (* "->" *) * type_) option
  * where_clause option
  * Token.t (* ";" *)
)

and function_type = (
    for_lifetimes option
  * [
        `Choice_id of anon_choice_type_id_2c46bcf
      | `Opt_func_modifs_fn of (
            function_modifiers option
          * Token.t (* "fn" *)
        )
    ]
  * parameters
  * (Token.t (* "->" *) * type_) option
)

and generic_type = (
    [
        `Id of identifier (*tok*)
      | `Choice_defa of reserved_identifier
      | `Scoped_type_id of scoped_type_identifier
    ]
  * type_arguments
)

and generic_type_with_turbofish = (
    anon_choice_type_id_f1f5a37 * Token.t (* "::" *) * type_arguments
)

and higher_ranked_trait_bound = (
    Token.t (* "for" *) * type_parameters * type_
)

and if_expression = (
    Token.t (* "if" *)
  * condition
  * block
  * else_clause option
)

and impl_item = (
    Token.t (* "unsafe" *) option
  * Token.t (* "impl" *)
  * type_parameters option
  * (
        Token.t (* "!" *) option
      * [
            `Id of identifier (*tok*)
          | `Scoped_type_id of scoped_type_identifier
          | `Gene_type of generic_type
        ]
      * Token.t (* "for" *)
    )
      option
  * type_
  * where_clause option
  * [ `Decl_list of declaration_list | `SEMI of Token.t (* ";" *) ]
)

and inner_attribute_item = (
    Token.t (* "#" *) * Token.t (* "!" *) * Token.t (* "[" *) * attribute
  * Token.t (* "]" *)
)

and last_match_arm = (
    attribute_item list (* zero or more *)
  * match_pattern
  * Token.t (* "=>" *)
  * expression
  * Token.t (* "," *) option
)

and let_chain = [
    `Let_chain_AMPAMP_let_cond of (
        let_chain * Token.t (* "&&" *) * let_condition
    )
  | `Let_chain_AMPAMP_exp of (let_chain * Token.t (* "&&" *) * expression)
  | `Let_cond_AMPAMP_exp of (let_condition * Token.t (* "&&" *) * expression)
  | `Let_cond_AMPAMP_let_cond of (
        let_condition * Token.t (* "&&" *) * let_condition
    )
  | `Exp_AMPAMP_let_cond of (expression * Token.t (* "&&" *) * let_condition)
]

and let_condition = (
    Token.t (* "let" *) * pattern * Token.t (* "=" *) * expression
)

and let_declaration = (
    Token.t (* "let" *)
  * Token.t (* "mut" *) option
  * pattern
  * (Token.t (* ":" *) * type_) option
  * (Token.t (* "=" *) * expression) option
  * (Token.t (* "else" *) * block) option
  * Token.t (* ";" *)
)

and macro_invocation = (
    [
        `Scoped_id of scoped_identifier
      | `Id of identifier (*tok*)
      | `Choice_defa of reserved_identifier
    ]
  * Token.t (* "!" *)
  * delim_token_tree
)

and match_arm = (
    attribute_item list (* zero or more *)
  * match_pattern
  * Token.t (* "=>" *)
  * [
        `Exp_COMMA of (expression * Token.t (* "," *))
      | `Choice_unsafe_blk of expression_ending_with_block
    ]
)

and match_block = (
    Token.t (* "{" *)
  * (match_arm list (* zero or more *) * last_match_arm) option
  * Token.t (* "}" *)
)

and match_pattern = (
    anon_choice_pat_17a3e23
  * (Token.t (* "if" *) * condition) option
)

and mod_item = (
    visibility_modifier option
  * Token.t (* "mod" *)
  * identifier (*tok*)
  * anon_choice_SEMI_226cc40
)

and ordered_field_declaration_list = (
    Token.t (* "(" *)
  * (
        attribute_item list (* zero or more *)
      * visibility_modifier option
      * type_
      * (
            Token.t (* "," *)
          * attribute_item list (* zero or more *)
          * visibility_modifier option
          * type_
        )
          list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* ")" *)
)

and parameter = (
    Token.t (* "mut" *) option
  * [ `Pat of pattern | `Self of Token.t (* "self" *) ]
  * Token.t (* ":" *)
  * type_
)

and parameters = (
    Token.t (* "(" *)
  * (
        attribute_item option
      * anon_choice_param_2c23cdc
      * (
            Token.t (* "," *)
          * attribute_item option
          * anon_choice_param_2c23cdc
        )
          list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* ")" *)
)

and path = [
    `Self of Token.t (* "self" *)
  | `Choice_u8 of anon_choice_u8_6dad923
  | `Meta of metavariable (*tok*)
  | `Super of Token.t (* "super" *)
  | `Crate of Token.t (* "crate" *)
  | `Id of identifier (*tok*)
  | `Scoped_id of scoped_identifier
  | `Choice_defa of reserved_identifier
]

and pattern = [
    `Lit_pat of literal_pattern
  | `Choice_u8 of anon_choice_u8_6dad923
  | `Id of identifier (*tok*)
  | `Scoped_id of scoped_identifier
  | `Tuple_pat of (
        Token.t (* "(" *)
      * (
            anon_choice_pat_17a3e23
          * (Token.t (* "," *) * anon_choice_pat_17a3e23)
              list (* zero or more *)
        )
          option
      * Token.t (* "," *) option
      * Token.t (* ")" *)
    )
  | `Tuple_struct_pat of (
        anon_choice_type_id_f1f5a37
      * Token.t (* "(" *)
      * anon_pat_rep_COMMA_pat_2a80f16 option
      * Token.t (* "," *) option
      * Token.t (* ")" *)
    )
  | `Struct_pat of (
        anon_choice_type_id_2c46bcf
      * Token.t (* "{" *)
      * (
            anon_choice_field_pat_8e757e8
          * (Token.t (* "," *) * anon_choice_field_pat_8e757e8)
              list (* zero or more *)
        )
          option
      * Token.t (* "," *) option
      * Token.t (* "}" *)
    )
  | `Choice_defa of reserved_identifier
  | `Ref_pat_a3d7f54 of (Token.t (* "ref" *) * pattern)
  | `Slice_pat of (
        Token.t (* "[" *)
      * anon_pat_rep_COMMA_pat_2a80f16 option
      * Token.t (* "," *) option
      * Token.t (* "]" *)
    )
  | `Capt_pat of (identifier (*tok*) * Token.t (* "@" *) * pattern)
  | `Ref_pat_dbbcf07 of (
        Token.t (* "&" *)
      * Token.t (* "mut" *) option
      * pattern
    )
  | `Rema_field_pat of Token.t (* ".." *)
  | `Mut_pat of (Token.t (* "mut" *) * pattern)
  | `Range_pat of (
        anon_choice_lit_pat_0884ef0
      * [
            `DOTDOTDOT of Token.t (* "..." *)
          | `DOTDOTEQ of Token.t (* "..=" *)
        ]
      * anon_choice_lit_pat_0884ef0
    )
  | `Or_pat of (pattern * Token.t (* "|" *) * pattern)
  | `Const_blk of const_block
  | `Macro_invo of macro_invocation
  | `X__ of Token.t (* "_" *)
]

and pointer_type = (
    Token.t (* "*" *)
  * [ `Const of Token.t (* "const" *) | `Muta_spec of Token.t (* "mut" *) ]
  * type_
)

and qualified_type = (type_ * Token.t (* "as" *) * type_)

and range_expression = [
    `Exp_choice_DOTDOT_exp of (
        expression
      * [
            `DOTDOT of Token.t (* ".." *)
          | `DOTDOTDOT of Token.t (* "..." *)
          | `DOTDOTEQ of Token.t (* "..=" *)
        ]
      * expression
    )
  | `Exp_DOTDOT of (expression * Token.t (* ".." *))
  | `DOTDOT_exp of base_field_initializer
  | `DOTDOT of Token.t (* ".." *)
]

and reference_type = (
    Token.t (* "&" *)
  * lifetime option
  * Token.t (* "mut" *) option
  * type_
)

and return_expression = [
    `Ret_exp of (Token.t (* "return" *) * expression)
  | `Ret of Token.t (* "return" *)
]

and scoped_identifier = (
    [
        `Choice_self of path
      | `Brac_type of bracketed_type
      | `Gene_type_with_turb of generic_type_with_turbofish
    ]
      option
  * Token.t (* "::" *)
  * [ `Id of identifier (*tok*) | `Super of Token.t (* "super" *) ]
)

and scoped_type_identifier = (
    [
        `Choice_self of path
      | `Gene_type_with_turb of generic_type_with_turbofish
      | `Brac_type of bracketed_type
      | `Gene_type of generic_type
    ]
      option
  * Token.t (* "::" *)
  * identifier (*tok*)
)

and scoped_type_identifier_in_expression_position = (
    [
        `Choice_self of path
      | `Gene_type_with_turb of generic_type_with_turbofish
    ]
      option
  * Token.t (* "::" *)
  * identifier (*tok*)
)

and semgrep_typed_metavar = (identifier (*tok*) * Token.t (* ":" *) * type_)

and statement = [
    `Exp_stmt of expression_statement
  | `Choice_choice_const_item of declaration_statement
]

and static_item = (
    visibility_modifier option
  * Token.t (* "static" *)
  * Token.t (* "ref" *) option
  * Token.t (* "mut" *) option
  * identifier (*tok*)
  * Token.t (* ":" *)
  * type_
  * (Token.t (* "=" *) * expression) option
  * Token.t (* ";" *)
)

and struct_item = (
    visibility_modifier option
  * Token.t (* "struct" *)
  * identifier (*tok*)
  * type_parameters option
  * [
        `Opt_where_clause_field_decl_list of (
            where_clause option
          * field_declaration_list
        )
      | `Orde_field_decl_list_opt_where_clause_SEMI of (
            ordered_field_declaration_list
          * where_clause option
          * Token.t (* ";" *)
        )
      | `SEMI of Token.t (* ";" *)
    ]
)

and trait_bounds = (
    Token.t (* ":" *)
  * anon_choice_type_d689819
  * (Token.t (* "+" *) * anon_choice_type_d689819) list (* zero or more *)
)

and trait_item = (
    visibility_modifier option
  * Token.t (* "unsafe" *) option
  * Token.t (* "trait" *)
  * identifier (*tok*)
  * type_parameters option
  * trait_bounds option
  * where_clause option
  * declaration_list
)

and tuple_type = (
    Token.t (* "(" *)
  * type_
  * (Token.t (* "," *) * type_) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* ")" *)
)

and type_ = [
    `Abst_type of (
        Token.t (* "impl" *)
      * (Token.t (* "for" *) * type_parameters) option
      * anon_choice_type_id_02b4436
    )
  | `Ref_type of reference_type
  | `Meta of metavariable (*tok*)
  | `Poin_type of pointer_type
  | `Gene_type of generic_type
  | `Scoped_type_id of scoped_type_identifier
  | `Tuple_type of tuple_type
  | `Unit_type of (Token.t (* "(" *) * Token.t (* ")" *))
  | `Array_type of array_type
  | `Func_type of function_type
  | `Id of identifier (*tok*)
  | `Macro_invo of macro_invocation
  | `Empty_type of Token.t (* "!" *)
  | `Dyna_type of (Token.t (* "dyn" *) * anon_choice_type_id_02b4436)
  | `Boun_type of bounded_type
  | `Choice_u8 of anon_choice_u8_6dad923
]

and type_arguments = (
    tok_prec_p1_lt (*tok*)
  * anon_choice_type_39799c3
  * (Token.t (* "," *) * anon_choice_type_39799c3) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* ">" *)
)

and type_item = (
    visibility_modifier option
  * Token.t (* "type" *)
  * identifier (*tok*)
  * type_parameters option
  * Token.t (* "=" *)
  * type_
  * where_clause option
  * Token.t (* ";" *)
)

and type_parameters = (
    Token.t (* "<" *)
  * anon_choice_life_859e88f
  * (Token.t (* "," *) * anon_choice_life_859e88f) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* ">" *)
)

and union_item = (
    visibility_modifier option
  * Token.t (* "union" *)
  * identifier (*tok*)
  * type_parameters option
  * where_clause option
  * field_declaration_list
)

and use_clause = [
    `Choice_self of path
  | `Use_as_clause of (path * Token.t (* "as" *) * identifier (*tok*))
  | `Use_list of use_list
  | `Scoped_use_list of (path option * Token.t (* "::" *) * use_list)
  | `Use_wild of ((path * Token.t (* "::" *)) option * Token.t (* "*" *))
]

and use_declaration = (
    visibility_modifier option
  * Token.t (* "use" *)
  * use_clause
  * Token.t (* ";" *)
)

and use_list = (
    Token.t (* "{" *)
  * (
        [ `Use_clause of use_clause ]
      * (Token.t (* "," *) * [ `Use_clause of use_clause ])
          list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)

and visibility_modifier = [
    `Crate of Token.t (* "crate" *)
  | `Pub_opt_LPAR_choice_self_RPAR of (
        Token.t (* "pub" *)
      * (
            Token.t (* "(" *)
          * [
                `Self of Token.t (* "self" *)
              | `Super of Token.t (* "super" *)
              | `Crate of Token.t (* "crate" *)
              | `In_choice_self of (Token.t (* "in" *) * path)
            ]
          * Token.t (* ")" *)
        )
          option
    )
]

and where_clause = (
    Token.t (* "where" *)
  * where_predicate
  * (Token.t (* "," *) * where_predicate) list (* zero or more *)
  * Token.t (* "," *) option
)

and where_predicate = (
    [
        `Life of lifetime
      | `Id of identifier (*tok*)
      | `Scoped_type_id of scoped_type_identifier
      | `Gene_type of generic_type
      | `Ref_type of reference_type
      | `Poin_type of pointer_type
      | `Tuple_type of tuple_type
      | `Array_type of array_type
      | `Higher_ranked_trait_bound of higher_ranked_trait_bound
      | `Choice_u8 of anon_choice_u8_6dad923
    ]
  * trait_bounds
)

and yield_expression = [
    `Yield_exp of (Token.t (* "yield" *) * expression)
  | `Yield of Token.t (* "yield" *)
]

type source_file = [
    `Opt_sheb_rep_stmt of (
        shebang (*tok*) option
      * statement list (* zero or more *)
    )
  | `Semg_exp of (Token.t (* "__SEMGREP_EXPRESSION" *) * expression)
  | `Semg_stmt of (
        Token.t (* "__SEMGREP_STATEMENT" *)
      * statement list (* one or more *)
    )
]

type ellipsis (* inlined *) = Token.t (* "..." *)

type empty_statement (* inlined *) = Token.t (* ";" *)

type self (* inlined *) = Token.t (* "self" *)

type empty_type (* inlined *) = Token.t (* "!" *)

type mutable_specifier (* inlined *) = Token.t (* "mut" *)

type unit_type (* inlined *) = (Token.t (* "(" *) * Token.t (* ")" *))

type unit_expression (* inlined *) = (Token.t (* "(" *) * Token.t (* ")" *))

type variadic_parameter (* inlined *) = Token.t (* "..." *)

type super (* inlined *) = Token.t (* "super" *)

type crate (* inlined *) = Token.t (* "crate" *)

type remaining_field_pattern (* inlined *) = Token.t (* ".." *)

type dummy_alias0 (* inlined *) = block_comment (*tok*)

type field_identifier (* inlined *) = identifier (*tok*)

type type_identifier (* inlined *) = identifier (*tok*)

type comment (* inlined *) = [
    `Line_comm_expl of line_comment_explicit (*tok*)
  | `Blk_comm_expl of block_comment_explicit (*tok*)
]

type token_binding_pattern (* inlined *) = (
    metavariable (*tok*) * Token.t (* ":" *) * fragment_specifier
)

type dummy_alias1 (* inlined *) = line_comment (*tok*)

type negative_literal (* inlined *) = (
    Token.t (* "-" *)
  * [
        `Int_lit of integer_literal (*tok*)
      | `Float_lit of float_literal (*tok*)
    ]
)

type continue_expression (* inlined *) = (
    Token.t (* "continue" *)
  * label option
)

type self_parameter (* inlined *) = (
    Token.t (* "&" *) option
  * lifetime option
  * Token.t (* "mut" *) option
  * Token.t (* "self" *)
)

type token_repetition_pattern (* inlined *) = (
    Token.t (* "$" *)
  * Token.t (* "(" *)
  * token_pattern list (* zero or more *)
  * Token.t (* ")" *)
  * pat_1e84e62 option
  * anon_choice_PLUS_348fa54
)

type token_repetition (* inlined *) = (
    Token.t (* "$" *)
  * Token.t (* "(" *)
  * tokens list (* zero or more *)
  * Token.t (* ")" *)
  * pat_1e84e62 option
  * anon_choice_PLUS_348fa54
)

type abstract_type (* inlined *) = (
    Token.t (* "impl" *)
  * (Token.t (* "for" *) * type_parameters) option
  * anon_choice_type_id_02b4436
)

type array_expression (* inlined *) = (
    Token.t (* "[" *)
  * attribute_item list (* zero or more *)
  * [
        `Exp_SEMI_exp of (expression * Token.t (* ";" *) * expression)
      | `Opt_rep_attr_item_exp_rep_COMMA_rep_attr_item_exp_opt_COMMA of (
            anon_opt_rep_attr_item_exp_rep_COMMA_rep_attr_item_exp_3d9e0d4
          * Token.t (* "," *) option
        )
    ]
  * Token.t (* "]" *)
)

type assignment_expression (* inlined *) = (
    expression * Token.t (* "=" *) * expression
)

type async_block (* inlined *) = (
    Token.t (* "async" *)
  * Token.t (* "move" *) option
  * block
)

type await_expression (* inlined *) = (
    expression * Token.t (* "." *) * Token.t (* "await" *)
)

type break_expression (* inlined *) = (
    Token.t (* "break" *)
  * label option
  * expression option
)

type call_expression (* inlined *) = (expression_except_range * arguments)

type captured_pattern (* inlined *) = (
    identifier (*tok*) * Token.t (* "@" *) * pattern
)

type compound_assignment_expr (* inlined *) = (
    expression
  * [
        `PLUSEQ of Token.t (* "+=" *)
      | `DASHEQ of Token.t (* "-=" *)
      | `STAREQ of Token.t (* "*=" *)
      | `SLASHEQ of Token.t (* "/=" *)
      | `PERCEQ of Token.t (* "%=" *)
      | `AMPEQ of Token.t (* "&=" *)
      | `BAREQ of Token.t (* "|=" *)
      | `HATEQ of Token.t (* "^=" *)
      | `LTLTEQ of Token.t (* "<<=" *)
      | `GTGTEQ of Token.t (* ">>=" *)
    ]
  * expression
)

type const_parameter (* inlined *) = (
    Token.t (* "const" *) * identifier (*tok*) * Token.t (* ":" *) * type_
)

type deep_ellipsis (* inlined *) = (
    Token.t (* "<..." *) * expression * Token.t (* "...>" *)
)

type dynamic_type (* inlined *) = (
    Token.t (* "dyn" *) * anon_choice_type_id_02b4436
)

type field_initializer (* inlined *) = (
    attribute_item list (* zero or more *)
  * identifier (*tok*)
  * Token.t (* ":" *)
  * expression
)

type field_pattern (* inlined *) = (
    Token.t (* "ref" *) option
  * Token.t (* "mut" *) option
  * [
        `Id of identifier (*tok*)
      | `Id_COLON_pat of (identifier (*tok*) * Token.t (* ":" *) * pattern)
    ]
)

type for_expression (* inlined *) = (
    (label * Token.t (* ":" *)) option
  * Token.t (* "for" *)
  * pattern
  * Token.t (* "in" *)
  * expression
  * block
)

type generic_function (* inlined *) = (
    [
        `Id of identifier (*tok*)
      | `Scoped_id of scoped_identifier
      | `Field_exp of field_expression
    ]
  * Token.t (* "::" *)
  * type_arguments
)

type index_expression (* inlined *) = (
    expression * Token.t (* "[" *) * expression * Token.t (* "]" *)
)

type loop_expression (* inlined *) = (
    (label * Token.t (* ":" *)) option
  * Token.t (* "loop" *)
  * block
)

type match_expression (* inlined *) = (
    Token.t (* "match" *) * expression * match_block
)

type member_access_ellipsis_expression (* inlined *) = (
    expression * Token.t (* "." *) * Token.t (* "..." *)
)

type mut_pattern (* inlined *) = (Token.t (* "mut" *) * pattern)

type optional_type_parameter (* inlined *) = (
    [
        `Id of identifier (*tok*)
      | `Cons_type_param of constrained_type_parameter
    ]
  * Token.t (* "=" *)
  * type_
)

type or_pattern (* inlined *) = (pattern * Token.t (* "|" *) * pattern)

type parenthesized_expression (* inlined *) = (
    Token.t (* "(" *)
  * [ `Exp of expression | `Semg_typed_meta of semgrep_typed_metavar ]
  * Token.t (* ")" *)
)

type range_pattern (* inlined *) = (
    anon_choice_lit_pat_0884ef0
  * [ `DOTDOTDOT of Token.t (* "..." *) | `DOTDOTEQ of Token.t (* "..=" *) ]
  * anon_choice_lit_pat_0884ef0
)

type ref_pattern (* inlined *) = (Token.t (* "ref" *) * pattern)

type reference_expression (* inlined *) = (
    Token.t (* "&" *)
  * Token.t (* "mut" *) option
  * expression
)

type reference_pattern (* inlined *) = (
    Token.t (* "&" *)
  * Token.t (* "mut" *) option
  * pattern
)

type removed_trait_bound (* inlined *) = (Token.t (* "?" *) * type_)

type scoped_use_list (* inlined *) = (
    path option
  * Token.t (* "::" *)
  * use_list
)

type shorthand_field_initializer (* inlined *) = (
    attribute_item list (* zero or more *)
  * identifier (*tok*)
)

type slice_pattern (* inlined *) = (
    Token.t (* "[" *)
  * anon_pat_rep_COMMA_pat_2a80f16 option
  * Token.t (* "," *) option
  * Token.t (* "]" *)
)

type struct_expression (* inlined *) = (
    [
        `Id of identifier (*tok*)
      | `Scoped_type_id_in_exp_posi of
          scoped_type_identifier_in_expression_position
      | `Gene_type_with_turb of generic_type_with_turbofish
    ]
  * field_initializer_list
)

type struct_pattern (* inlined *) = (
    anon_choice_type_id_2c46bcf
  * Token.t (* "{" *)
  * (
        anon_choice_field_pat_8e757e8
      * (Token.t (* "," *) * anon_choice_field_pat_8e757e8)
          list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)

type try_block (* inlined *) = (Token.t (* "try" *) * block)

type try_expression (* inlined *) = (expression * Token.t (* "?" *))

type tuple_expression (* inlined *) = (
    Token.t (* "(" *)
  * attribute_item list (* zero or more *)
  * expression
  * Token.t (* "," *)
  * (expression * Token.t (* "," *)) list (* zero or more *)
  * expression option
  * Token.t (* ")" *)
)

type tuple_pattern (* inlined *) = (
    Token.t (* "(" *)
  * (
        anon_choice_pat_17a3e23
      * (Token.t (* "," *) * anon_choice_pat_17a3e23) list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* ")" *)
)

type tuple_struct_pattern (* inlined *) = (
    anon_choice_type_id_f1f5a37
  * Token.t (* "(" *)
  * anon_pat_rep_COMMA_pat_2a80f16 option
  * Token.t (* "," *) option
  * Token.t (* ")" *)
)

type type_binding (* inlined *) = (
    identifier (*tok*)
  * type_arguments option
  * Token.t (* "=" *)
  * type_
)

type type_cast_expression (* inlined *) = (
    expression * Token.t (* "as" *) * type_
)

type unary_expression (* inlined *) = (
    [
        `DASH of Token.t (* "-" *)
      | `STAR of Token.t (* "*" *)
      | `BANG of Token.t (* "!" *)
    ]
  * expression
)

type unsafe_block (* inlined *) = (Token.t (* "unsafe" *) * block)

type use_as_clause (* inlined *) = (
    path * Token.t (* "as" *) * identifier (*tok*)
)

type use_wildcard (* inlined *) = (
    (path * Token.t (* "::" *)) option
  * Token.t (* "*" *)
)

type while_expression (* inlined *) = (
    (label * Token.t (* ":" *)) option
  * Token.t (* "while" *)
  * condition
  * block
)

type semgrep_statement (* inlined *) = (
    Token.t (* "__SEMGREP_STATEMENT" *)
  * statement list (* one or more *)
)

type semgrep_expression (* inlined *) = (
    Token.t (* "__SEMGREP_EXPRESSION" *) * expression
)

type extra = [
    `Line_comment of Loc.t * line_comment
  | `Block_comment of Loc.t * block_comment
]

type extras = extra list
