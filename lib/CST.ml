(* Generated by ocaml-tree-sitter. *)
(*
   rust grammar

   entrypoint: source_file
*)

open! Sexplib.Conv
open Tree_sitter_run

type float_literal = Token.t
[@@deriving sexp_of]

type pat_1e84e62 = Token.t (* pattern [^+*?]+ *)
[@@deriving sexp_of]

type escape_sequence = Token.t
[@@deriving sexp_of]

type boolean_literal = [
    `True of Token.t (* "true" *)
  | `False of Token.t (* "false" *)
]
[@@deriving sexp_of]

type reserved_identifier = [
    `Defa of Token.t (* "default" *)
  | `Union of Token.t (* "union" *)
]
[@@deriving sexp_of]

type string_content = Token.t
[@@deriving sexp_of]

type anon_choice_PLUS_348fa54 = [
    `PLUS of Token.t (* "+" *)
  | `STAR of Token.t (* "*" *)
  | `QMARK of Token.t (* "?" *)
]
[@@deriving sexp_of]

type line_comment = Token.t
[@@deriving sexp_of]

type identifier = Token.t
[@@deriving sexp_of]

type block_comment = Token.t
[@@deriving sexp_of]

type anon_choice_u8_6dad923 = [
    `U8 of Token.t (* "u8" *)
  | `I8 of Token.t (* "i8" *)
  | `U16 of Token.t (* "u16" *)
  | `I16 of Token.t (* "i16" *)
  | `U32 of Token.t (* "u32" *)
  | `I32 of Token.t (* "i32" *)
  | `U64 of Token.t (* "u64" *)
  | `I64 of Token.t (* "i64" *)
  | `U128 of Token.t (* "u128" *)
  | `I128 of Token.t (* "i128" *)
  | `Isize of Token.t (* "isize" *)
  | `Usize of Token.t (* "usize" *)
  | `F32 of Token.t (* "f32" *)
  | `F64 of Token.t (* "f64" *)
  | `Bool of Token.t (* "bool" *)
  | `Str of Token.t (* "str" *)
  | `Char of Token.t (* "char" *)
]
[@@deriving sexp_of]

type fragment_specifier = [
    `Blk of Token.t (* "block" *)
  | `Expr of Token.t (* "expr" *)
  | `Id of Token.t (* "ident" *)
  | `Item of Token.t (* "item" *)
  | `Life of Token.t (* "lifetime" *)
  | `Lit of Token.t (* "literal" *)
  | `Meta of Token.t (* "meta" *)
  | `Pat of Token.t (* "pat" *)
  | `Path of Token.t (* "path" *)
  | `Stmt of Token.t (* "stmt" *)
  | `Tt of Token.t (* "tt" *)
  | `Ty of Token.t (* "ty" *)
  | `Vis of Token.t (* "vis" *)
]
[@@deriving sexp_of]

type tok_LT = Token.t
[@@deriving sexp_of]

type pat_36c5a8e = Token.t (* pattern "b?\"" *)
[@@deriving sexp_of]

type integer_literal = Token.t
[@@deriving sexp_of]

type pat_785a82e = Token.t (* pattern [/_\-=->,;:::!=?.@*=/=&=#%=^=+<>|~]+ *)
[@@deriving sexp_of]

type char_literal = Token.t
[@@deriving sexp_of]

type metavariable = Token.t (* pattern \$[a-zA-Z_]\w* *)
[@@deriving sexp_of]

type raw_string_literal = Token.t
[@@deriving sexp_of]

type string_literal = (
    pat_36c5a8e (*tok*)
  * [
        `Esc_seq of escape_sequence (*tok*)
      | `Str_content of string_content (*tok*)
    ]
      list (* zero or more *)
  * Token.t (* "\"" *)
)
[@@deriving sexp_of]

type simple_path = [
    `Self of Token.t (* "self" *)
  | `Choice_u8 of anon_choice_u8_6dad923
  | `Meta of metavariable (*tok*)
  | `Super of Token.t (* "super" *)
  | `Crate of Token.t (* "crate" *)
  | `Id of identifier (*tok*)
  | `Simple_scoped_id of simple_scoped_identifier
]

and simple_scoped_identifier = (
    simple_path * Token.t (* "::" *) * identifier (*tok*)
)
[@@deriving sexp_of]

type lifetime = (Token.t (* "'" *) * identifier (*tok*))
[@@deriving sexp_of]

type loop_label = (Token.t (* "'" *) * identifier (*tok*))
[@@deriving sexp_of]

type foreign_item_type = (
    Token.t (* "type" *) * identifier (*tok*) * Token.t (* ";" *)
)
[@@deriving sexp_of]

type extern_modifier = (Token.t (* "extern" *) * string_literal option)
[@@deriving sexp_of]

type literal = [
    `Str_lit of string_literal
  | `Raw_str_lit of raw_string_literal (*tok*)
  | `Char_lit of char_literal (*tok*)
  | `Bool_lit of boolean_literal
  | `Int_lit of integer_literal (*tok*)
  | `Float_lit of float_literal (*tok*)
]
[@@deriving sexp_of]

type literal_pattern = [
    `Str_lit of string_literal
  | `Raw_str_lit of raw_string_literal (*tok*)
  | `Char_lit of char_literal (*tok*)
  | `Bool_lit of boolean_literal
  | `Int_lit of integer_literal (*tok*)
  | `Float_lit of float_literal (*tok*)
  | `Nega_lit of (
        Token.t (* "-" *)
      * [
            `Int_lit of integer_literal (*tok*)
          | `Float_lit of float_literal (*tok*)
        ]
    )
]
[@@deriving sexp_of]

type visibility_modifier = [
    `Crate of Token.t (* "crate" *)
  | `Pub_opt_LPAR_choice_self_RPAR of (
        Token.t (* "pub" *)
      * (
            Token.t (* "(" *)
          * [
                `Self of Token.t (* "self" *)
              | `Super of Token.t (* "super" *)
              | `Crate of Token.t (* "crate" *)
              | `In_choice_self of (Token.t (* "in" *) * simple_path)
            ]
          * Token.t (* ")" *)
        )
          option
    )
]
[@@deriving sexp_of]

type for_lifetimes = (
    Token.t (* "for" *)
  * Token.t (* "<" *)
  * lifetime
  * (Token.t (* "," *) * lifetime) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* ">" *)
)
[@@deriving sexp_of]

type function_modifiers =
  [
      `Async of Token.t (* "async" *)
    | `Defa of Token.t (* "default" *)
    | `Const of Token.t (* "const" *)
    | `Unsafe of Token.t (* "unsafe" *)
    | `Extern_modi of extern_modifier
  ]
    list (* one or more *)
[@@deriving sexp_of]

type non_special_token = [
    `Lit of literal
  | `Id of identifier (*tok*)
  | `Meta of metavariable (*tok*)
  | `Muta_spec of Token.t (* "mut" *)
  | `Self of Token.t (* "self" *)
  | `Super of Token.t (* "super" *)
  | `Crate of Token.t (* "crate" *)
  | `Choice_u8 of anon_choice_u8_6dad923
  | `Pat_785a82e of pat_785a82e (*tok*)
  | `SQUOT of Token.t (* "'" *)
  | `As of Token.t (* "as" *)
  | `Async of Token.t (* "async" *)
  | `Await of Token.t (* "await" *)
  | `Brk of Token.t (* "break" *)
  | `Const of Token.t (* "const" *)
  | `Cont of Token.t (* "continue" *)
  | `Defa of Token.t (* "default" *)
  | `Enum of Token.t (* "enum" *)
  | `Fn of Token.t (* "fn" *)
  | `For of Token.t (* "for" *)
  | `If of Token.t (* "if" *)
  | `Impl of Token.t (* "impl" *)
  | `Let of Token.t (* "let" *)
  | `Loop of Token.t (* "loop" *)
  | `Match of Token.t (* "match" *)
  | `Mod of Token.t (* "mod" *)
  | `Pub of Token.t (* "pub" *)
  | `Ret of Token.t (* "return" *)
  | `Static of Token.t (* "static" *)
  | `Struct of Token.t (* "struct" *)
  | `Trait of Token.t (* "trait" *)
  | `Type of Token.t (* "type" *)
  | `Union of Token.t (* "union" *)
  | `Unsafe of Token.t (* "unsafe" *)
  | `Use of Token.t (* "use" *)
  | `Where of Token.t (* "where" *)
  | `While of Token.t (* "while" *)
]
[@@deriving sexp_of]

type anon_choice_meta_item_fefa160 = [
    `Meta_item of meta_item
  | `Lit of literal
]

and meta_arguments = (
    Token.t (* "(" *)
  * (
        anon_choice_meta_item_fefa160
      * (Token.t (* "," *) * anon_choice_meta_item_fefa160)
          list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* ")" *)
)

and meta_item = (
    simple_path
  * [
        `EQ_lit of (Token.t (* "=" *) * literal)
      | `Meta_args of meta_arguments
    ]
      option
)
[@@deriving sexp_of]

type use_clause = [
    `Choice_self of simple_path
  | `Use_as_clause of (simple_path * Token.t (* "as" *) * identifier (*tok*))
  | `Use_list of use_list
  | `Scoped_use_list of (simple_path option * Token.t (* "::" *) * use_list)
  | `Use_wild of (
        (simple_path * Token.t (* "::" *)) option
      * Token.t (* "*" *)
    )
]

and use_list = (
    Token.t (* "{" *)
  * (
        [ `Use_clause of use_clause ]
      * (Token.t (* "," *) * [ `Use_clause of use_clause ])
          list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)
[@@deriving sexp_of]

type token_tree = [
    `LPAR_rep_choice_tok_tree_RPAR of (
        Token.t (* "(" *)
      * tokens list (* zero or more *)
      * Token.t (* ")" *)
    )
  | `LBRACK_rep_choice_tok_tree_RBRACK of (
        Token.t (* "[" *)
      * tokens list (* zero or more *)
      * Token.t (* "]" *)
    )
  | `LCURL_rep_choice_tok_tree_RCURL of (
        Token.t (* "{" *)
      * tokens list (* zero or more *)
      * Token.t (* "}" *)
    )
]

and tokens = [
    `Tok_tree of token_tree
  | `Tok_repe of (
        Token.t (* "$" *)
      * Token.t (* "(" *)
      * tokens list (* zero or more *)
      * Token.t (* ")" *)
      * pat_1e84e62 (*tok*) option
      * anon_choice_PLUS_348fa54
    )
  | `Choice_lit of non_special_token
]
[@@deriving sexp_of]

type token_pattern = [
    `Tok_tree_pat of token_tree_pattern
  | `Tok_repe_pat of (
        Token.t (* "$" *)
      * Token.t (* "(" *)
      * token_pattern list (* zero or more *)
      * Token.t (* ")" *)
      * pat_1e84e62 (*tok*) option
      * anon_choice_PLUS_348fa54
    )
  | `Tok_bind_pat of (
        metavariable (*tok*) * Token.t (* ":" *) * fragment_specifier
    )
  | `Choice_lit of non_special_token
]

and token_tree_pattern = [
    `LPAR_rep_tok_pat_RPAR of (
        Token.t (* "(" *)
      * token_pattern list (* zero or more *)
      * Token.t (* ")" *)
    )
  | `LBRACK_rep_tok_pat_RBRACK of (
        Token.t (* "[" *)
      * token_pattern list (* zero or more *)
      * Token.t (* "]" *)
    )
  | `LCURL_rep_tok_pat_RCURL of (
        Token.t (* "{" *)
      * token_pattern list (* zero or more *)
      * Token.t (* "}" *)
    )
]
[@@deriving sexp_of]

type attribute = (Token.t (* "[" *) * meta_item * Token.t (* "]" *))
[@@deriving sexp_of]

type macro_invocation = (
    [
        `Simple_scoped_id of simple_scoped_identifier
      | `Id of identifier (*tok*)
    ]
  * Token.t (* "!" *)
  * token_tree
)
[@@deriving sexp_of]

type macro_rule = (token_tree_pattern * Token.t (* "=>" *) * token_tree)
[@@deriving sexp_of]

type inner_attribute_item = (
    Token.t (* "#" *) * Token.t (* "!" *) * attribute
)
[@@deriving sexp_of]

type outer_attribute_item = (Token.t (* "#" *) * attribute)
[@@deriving sexp_of]

type anon_choice_field_pat_8e757e8 = [
    `Field_pat of (
        Token.t (* "ref" *) option
      * Token.t (* "mut" *) option
      * [
            `Id of identifier (*tok*)
          | `Id_COLON_pat of (
                identifier (*tok*) * Token.t (* ":" *) * pattern
            )
        ]
    )
  | `Rema_field_pat of Token.t (* ".." *)
]

and anon_choice_life_859e88f = [
    `Life of lifetime
  | `Meta of metavariable (*tok*)
  | `Id of identifier (*tok*)
  | `Cons_type_param of constrained_type_parameter
  | `Opt_type_param of (
        [
            `Id of identifier (*tok*)
          | `Cons_type_param of constrained_type_parameter
        ]
      * Token.t (* "=" *)
      * type_
    )
  | `Const_param of (
        Token.t (* "const" *) * identifier (*tok*) * Token.t (* ":" *)
      * type_
    )
]

and anon_choice_lit_pat_0884ef0 = [
    `Lit_pat of literal_pattern
  | `Choice_self of path
]

and anon_choice_param_2c23cdc = [
    `Param of parameter
  | `Self_param of (
        Token.t (* "&" *) option
      * lifetime option
      * Token.t (* "mut" *) option
      * Token.t (* "self" *)
    )
  | `Vari_param of Token.t (* "..." *)
  | `X__ of Token.t (* "_" *)
  | `Type of type_
]

and anon_choice_pat_4717dcc = [ `Pat of pattern | `Param of parameter ]

and anon_choice_shor_field_init_9cb4441 = [
    `Shor_field_init of (
        outer_attribute_item list (* zero or more *)
      * identifier (*tok*)
    )
  | `Field_init of (
        outer_attribute_item list (* zero or more *)
      * identifier (*tok*)
      * Token.t (* ":" *)
      * expression
    )
  | `Base_field_init of base_field_initializer
]

and anon_choice_type_39799c3 = [
    `Type of type_
  | `Type_bind of (identifier (*tok*) * Token.t (* "=" *) * type_)
  | `Life of lifetime
  | `Lit of literal
  | `Blk of block
]

and anon_choice_type_d689819 = [
    `Type of type_
  | `Life of lifetime
  | `Higher_ranked_trait_bound of higher_ranked_trait_bound
  | `Remo_trait_bound of (Token.t (* "?" *) * type_)
]

and anon_choice_type_id_02b4436 = [
    `Id of identifier (*tok*)
  | `Scoped_type_id of scoped_type_identifier
  | `Gene_type of generic_type
  | `Func_type of function_type
]

and anon_choice_type_id_2c46bcf = [
    `Id of identifier (*tok*)
  | `Scoped_type_id of scoped_type_identifier
]

and anon_choice_type_id_f1f5a37 = [
    `Id of identifier (*tok*)
  | `Scoped_id of scoped_identifier
]

and anon_pat_rep_COMMA_pat_2a80f16 = (
    pattern
  * (Token.t (* "," *) * pattern) list (* zero or more *)
)

and arguments = (
    Token.t (* "(" *)
  * (
        outer_attribute_item list (* zero or more *)
      * expression
      * (
            Token.t (* "," *)
          * outer_attribute_item list (* zero or more *)
          * expression
        )
          list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* ")" *)
)

and associated_type = (
    Token.t (* "type" *)
  * identifier (*tok*)
  * type_parameters option
  * trait_bounds option
  * (Token.t (* "=" *) * type_) option
  * Token.t (* ";" *)
)

and base_field_initializer = (Token.t (* ".." *) * expression)

and binary_expression = [
    `Exp_AMPAMP_exp of (expression * Token.t (* "&&" *) * expression)
  | `Exp_BARBAR_exp of (expression * Token.t (* "||" *) * expression)
  | `Exp_AMP_exp of (expression * Token.t (* "&" *) * expression)
  | `Exp_BAR_exp of (expression * Token.t (* "|" *) * expression)
  | `Exp_HAT_exp of (expression * Token.t (* "^" *) * expression)
  | `Exp_choice_EQEQ_exp of (
        expression
      * [
            `EQEQ of Token.t (* "==" *)
          | `BANGEQ of Token.t (* "!=" *)
          | `LT of Token.t (* "<" *)
          | `LTEQ of Token.t (* "<=" *)
          | `GT of Token.t (* ">" *)
          | `GTEQ of Token.t (* ">=" *)
        ]
      * expression
    )
  | `Exp_choice_LTLT_exp of (
        expression
      * [ `LTLT of Token.t (* "<<" *) | `GTGT of Token.t (* ">>" *) ]
      * expression
    )
  | `Exp_choice_PLUS_exp of (
        expression
      * [ `PLUS of Token.t (* "+" *) | `DASH of Token.t (* "-" *) ]
      * expression
    )
  | `Exp_choice_STAR_exp of (
        expression
      * [
            `STAR of Token.t (* "*" *)
          | `SLASH of Token.t (* "/" *)
          | `PERC of Token.t (* "%" *)
        ]
      * expression
    )
]

and block = (
    Token.t (* "{" *)
  * statement list (* zero or more *)
  * expression option
  * Token.t (* "}" *)
)

and bounded_type = [
    `Life_PLUS_type of (lifetime * Token.t (* "+" *) * type_)
  | `Type_PLUS_type of (type_ * Token.t (* "+" *) * type_)
  | `Type_PLUS_life of (type_ * Token.t (* "+" *) * lifetime)
]

and bracketed_type = (
    Token.t (* "<" *)
  * [ `Type of type_ | `Qual_type of qualified_type ]
  * Token.t (* ">" *)
)

and closure_parameters = (
    Token.t (* "|" *)
  * (
        anon_choice_pat_4717dcc
      * (Token.t (* "," *) * anon_choice_pat_4717dcc) list (* zero or more *)
    )
      option
  * Token.t (* "|" *)
)

and const_block = (Token.t (* "const" *) * block)

and const_item = (
    Token.t (* "const" *)
  * identifier (*tok*)
  * Token.t (* ":" *)
  * type_
  * (Token.t (* "=" *) * expression) option
  * Token.t (* ";" *)
)

and constrained_type_parameter = (
    [ `Life of lifetime | `Id of identifier (*tok*) ]
  * trait_bounds
)

and else_clause = (
    Token.t (* "else" *)
  * [
        `Blk of block
      | `If_exp of if_expression
      | `If_let_exp of if_let_expression
    ]
)

and enum_variant = (
    visibility_modifier option
  * identifier (*tok*)
  * [
        `Field_decl_list of field_declaration_list
      | `Orde_field_decl_list of ordered_field_declaration_list
    ]
      option
  * (Token.t (* "=" *) * expression) option
)

and enum_variant_list = (
    Token.t (* "{" *)
  * (
        outer_attribute_item list (* zero or more *)
      * enum_variant
      * (
            Token.t (* "," *)
          * outer_attribute_item list (* zero or more *)
          * enum_variant
        )
          list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)

and expression = [
    `Un_exp of (
        [
            `DASH of Token.t (* "-" *)
          | `STAR of Token.t (* "*" *)
          | `BANG of Token.t (* "!" *)
        ]
      * expression
    )
  | `Ref_exp of (Token.t (* "&" *) * Token.t (* "mut" *) option * expression)
  | `Try_exp of (expression * Token.t (* "?" *))
  | `Bin_exp of binary_expression
  | `Assign_exp of (expression * Token.t (* "=" *) * expression)
  | `Comp_assign_expr of (
        expression
      * [
            `PLUSEQ of Token.t (* "+=" *)
          | `DASHEQ of Token.t (* "-=" *)
          | `STAREQ of Token.t (* "*=" *)
          | `SLASHEQ of Token.t (* "/=" *)
          | `PERCEQ of Token.t (* "%=" *)
          | `AMPEQ of Token.t (* "&=" *)
          | `BAREQ of Token.t (* "|=" *)
          | `HATEQ of Token.t (* "^=" *)
          | `LTLTEQ of Token.t (* "<<=" *)
          | `GTGTEQ of Token.t (* ">>=" *)
        ]
      * expression
    )
  | `Type_cast_exp of (expression * Token.t (* "as" *) * type_)
  | `Range_exp of range_expression
  | `Call_exp of (expression * arguments)
  | `Ret_exp of return_expression
  | `Lit of literal
  | `Id of identifier (*tok*)
  | `Choice_u8 of anon_choice_u8_6dad923
  | `Choice_defa of reserved_identifier
  | `Self of Token.t (* "self" *)
  | `Scoped_id of scoped_identifier
  | `Gene_func of (
        [
            `Id of identifier (*tok*)
          | `Scoped_id of scoped_identifier
          | `Field_exp of field_expression
        ]
      * Token.t (* "::" *)
      * type_arguments
    )
  | `Await_exp of (expression * Token.t (* "." *) * Token.t (* "await" *))
  | `Field_exp of field_expression
  | `Array_exp of (
        Token.t (* "[" *)
      * outer_attribute_item list (* zero or more *)
      * [
            `Exp_SEMI_exp of (expression * Token.t (* ";" *) * expression)
          | `Opt_exp_rep_COMMA_exp_opt_COMMA of (
                (
                    expression
                  * (Token.t (* "," *) * expression) list (* zero or more *)
                )
                  option
              * Token.t (* "," *) option
            )
        ]
      * Token.t (* "]" *)
    )
  | `Tuple_exp of (
        Token.t (* "(" *)
      * outer_attribute_item list (* zero or more *)
      * expression
      * Token.t (* "," *)
      * (expression * Token.t (* "," *)) list (* zero or more *)
      * expression option
      * Token.t (* ")" *)
    )
  | `Macro_invo of macro_invocation
  | `Unit_exp of (Token.t (* "(" *) * Token.t (* ")" *))
  | `Choice_unsafe_blk of expression_ending_with_block
  | `Brk_exp of (
        Token.t (* "break" *)
      * loop_label option
      * expression option
    )
  | `Cont_exp of (Token.t (* "continue" *) * loop_label option)
  | `Index_exp of (
        expression * Token.t (* "[" *) * expression * Token.t (* "]" *)
    )
  | `Meta of metavariable (*tok*)
  | `Clos_exp of (
        Token.t (* "move" *) option
      * closure_parameters
      * [
            `Opt_DASHGT_type_blk of (
                (Token.t (* "->" *) * type_) option
              * block
            )
          | `Exp of expression
        ]
    )
  | `Paren_exp of (Token.t (* "(" *) * expression * Token.t (* ")" *))
  | `Struct_exp of (
        [
            `Id of identifier (*tok*)
          | `Scoped_type_id_in_exp_posi of
              scoped_type_identifier_in_expression_position
          | `Gene_type_with_turb of generic_type_with_turbofish
        ]
      * field_initializer_list
    )
  | `Ellips of Token.t (* "..." *)
  | `Deep_ellips of (
        Token.t (* "<..." *) * expression * Token.t (* "...>" *)
    )
]

and expression_ending_with_block = [
    `Unsafe_blk of (Token.t (* "unsafe" *) * block)
  | `Async_blk of (
        Token.t (* "async" *)
      * Token.t (* "move" *) option
      * block
    )
  | `Blk of block
  | `If_exp of if_expression
  | `If_let_exp of if_let_expression
  | `Match_exp of (Token.t (* "match" *) * expression * match_block)
  | `While_exp of (
        (loop_label * Token.t (* ":" *)) option
      * Token.t (* "while" *)
      * expression
      * block
    )
  | `While_let_exp of (
        (loop_label * Token.t (* ":" *)) option
      * Token.t (* "while" *)
      * Token.t (* "let" *)
      * pattern
      * Token.t (* "=" *)
      * expression
      * block
    )
  | `Loop_exp of (
        (loop_label * Token.t (* ":" *)) option
      * Token.t (* "loop" *)
      * block
    )
  | `For_exp of (
        (loop_label * Token.t (* ":" *)) option
      * Token.t (* "for" *)
      * pattern
      * Token.t (* "in" *)
      * expression
      * block
    )
  | `Const_blk of const_block
]

and expression_statement = [
    `Choice_exp_SEMI of [
        `Exp_SEMI of (expression * Token.t (* ";" *))
      | `Choice_unsafe_blk of expression_ending_with_block
    ]
  | `Ellips_SEMI of (Token.t (* "..." *) * Token.t (* ";" *))
  | `Ellips of Token.t (* "..." *)
]

and field_declaration = (
    visibility_modifier option
  * identifier (*tok*)
  * Token.t (* ":" *)
  * type_
)

and field_declaration_list = (
    Token.t (* "{" *)
  * (
        outer_attribute_item list (* zero or more *)
      * field_declaration
      * (
            Token.t (* "," *)
          * outer_attribute_item list (* zero or more *)
          * field_declaration
        )
          list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)

and field_expression = (
    expression
  * Token.t (* "." *)
  * [ `Id of identifier (*tok*) | `Int_lit of integer_literal (*tok*) ]
)

and field_initializer_list = (
    Token.t (* "{" *)
  * (
        anon_choice_shor_field_init_9cb4441
      * (Token.t (* "," *) * anon_choice_shor_field_init_9cb4441)
          list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)

and foreign_block_item = (
    outer_attribute_item list (* zero or more *)
  * visibility_modifier option
  * [
        `Fore_item_static of foreign_item_static
      | `Func_sign_with_defa_item of function_signature_with_default_item
      | `Fore_item_type of foreign_item_type
      | `Macro_invo of macro_invocation
    ]
)

and foreign_item_static = (
    Token.t (* "static" *)
  * Token.t (* "mut" *) option
  * identifier (*tok*)
  * Token.t (* ":" *)
  * type_
  * Token.t (* ";" *)
)

and foreign_mod_block = (
    Token.t (* "{" *)
  * inner_attribute_item list (* zero or more *)
  * foreign_block_item list (* zero or more *)
  * Token.t (* "}" *)
)

and function_declaration = (
    [ `Id of identifier (*tok*) | `Meta of metavariable (*tok*) ]
  * type_parameters option
  * parameters
  * (Token.t (* "->" *) * type_) option
  * where_clause option
)

and function_item = (
    function_modifiers option
  * Token.t (* "fn" *)
  * function_declaration
  * block
)

and function_signature_with_default_item = (
    function_modifiers option
  * Token.t (* "fn" *)
  * function_declaration
  * [ `SEMI of Token.t (* ";" *) | `Blk of block ]
)

and function_type = (
    for_lifetimes option
  * [
        `Choice_id of anon_choice_type_id_2c46bcf
      | `Opt_func_modifs_fn of (
            function_modifiers option
          * Token.t (* "fn" *)
        )
    ]
  * parameters
  * (Token.t (* "->" *) * type_) option
)

and generic_type = (anon_choice_type_id_2c46bcf * type_arguments)

and generic_type_with_turbofish = (
    anon_choice_type_id_f1f5a37 * Token.t (* "::" *) * type_arguments
)

and higher_ranked_trait_bound = (
    Token.t (* "for" *) * type_parameters * type_
)

and if_expression = (
    Token.t (* "if" *)
  * expression
  * block
  * else_clause option
)

and if_let_expression = (
    Token.t (* "if" *)
  * Token.t (* "let" *)
  * pattern
  * Token.t (* "=" *)
  * expression
  * block
  * else_clause option
)

and impl_block = (
    Token.t (* "{" *)
  * inner_attribute_item list (* zero or more *)
  * impl_block_item list (* zero or more *)
  * Token.t (* "}" *)
)

and impl_block_item = (
    outer_attribute_item list (* zero or more *)
  * visibility_modifier option
  * [
        `Impl_blk_item_const of impl_block_item_const
      | `Func_item of function_item
      | `Impl_blk_item_type of impl_block_item_type
      | `Macro_invo of macro_invocation
    ]
)

and impl_block_item_const = (
    Token.t (* "const" *) * identifier (*tok*) * Token.t (* ":" *) * type_
  * Token.t (* "=" *) * expression * Token.t (* ";" *)
)

and impl_block_item_type = (
    Token.t (* "type" *)
  * identifier (*tok*)
  * type_parameters option
  * Token.t (* "=" *)
  * type_
  * Token.t (* ";" *)
)

and item = (
    outer_attribute_item list (* zero or more *)
  * visibility_modifier option
  * item_kind
)

and item_kind = [
    `Const_item of const_item
  | `Macro_invo of macro_invocation
  | `Macro_defi of (
        Token.t (* "macro_rules!" *)
      * identifier (*tok*)
      * [
            `LPAR_rep_macro_rule_SEMI_opt_macro_rule_RPAR_SEMI of (
                Token.t (* "(" *)
              * (macro_rule * Token.t (* ";" *)) list (* zero or more *)
              * macro_rule option
              * Token.t (* ")" *)
              * Token.t (* ";" *)
            )
          | `LCURL_rep_macro_rule_SEMI_opt_macro_rule_RCURL of (
                Token.t (* "{" *)
              * (macro_rule * Token.t (* ";" *)) list (* zero or more *)
              * macro_rule option
              * Token.t (* "}" *)
            )
        ]
    )
  | `Empty_stmt of Token.t (* ";" *)
  | `Mod_item of (
        Token.t (* "mod" *)
      * identifier (*tok*)
      * [ `SEMI of Token.t (* ";" *) | `Mod_blk of mod_block ]
    )
  | `Fore_mod_item of (
        extern_modifier
      * [ `SEMI of Token.t (* ";" *) | `Fore_mod_blk of foreign_mod_block ]
    )
  | `Struct_item of (
        Token.t (* "struct" *)
      * identifier (*tok*)
      * type_parameters option
      * [
            `Opt_where_clause_field_decl_list of (
                where_clause option
              * field_declaration_list
            )
          | `Orde_field_decl_list_opt_where_clause_SEMI of (
                ordered_field_declaration_list
              * where_clause option
              * Token.t (* ";" *)
            )
          | `SEMI of Token.t (* ";" *)
        ]
    )
  | `Union_item of (
        Token.t (* "union" *)
      * identifier (*tok*)
      * type_parameters option
      * where_clause option
      * field_declaration_list
    )
  | `Enum_item of (
        Token.t (* "enum" *)
      * identifier (*tok*)
      * type_parameters option
      * where_clause option
      * enum_variant_list
    )
  | `Type_item of (
        Token.t (* "type" *)
      * identifier (*tok*)
      * type_parameters option
      * Token.t (* "=" *)
      * type_
      * Token.t (* ";" *)
    )
  | `Func_item of function_item
  | `Func_sign_item of (
        function_modifiers option
      * Token.t (* "fn" *)
      * function_declaration
      * Token.t (* ";" *)
    )
  | `Impl_item of (
        Token.t (* "unsafe" *) option
      * Token.t (* "impl" *)
      * type_parameters option
      * (
            [
                `Id of identifier (*tok*)
              | `Scoped_type_id of scoped_type_identifier
              | `Gene_type of generic_type
            ]
          * Token.t (* "for" *)
        )
          option
      * type_
      * where_clause option
      * impl_block
    )
  | `Trait_item of (
        Token.t (* "unsafe" *) option
      * Token.t (* "trait" *)
      * identifier (*tok*)
      * type_parameters option
      * trait_bounds option
      * where_clause option
      * trait_block
    )
  | `Use_decl of (Token.t (* "use" *) * use_clause * Token.t (* ";" *))
  | `Extern_crate_decl of (
        Token.t (* "extern" *)
      * Token.t (* "crate" *)
      * identifier (*tok*)
      * (Token.t (* "as" *) * identifier (*tok*)) option
      * Token.t (* ";" *)
    )
  | `Static_item of (
        Token.t (* "static" *)
      * Token.t (* "ref" *) option
      * Token.t (* "mut" *) option
      * identifier (*tok*)
      * Token.t (* ":" *)
      * type_
      * (Token.t (* "=" *) * expression) option
      * Token.t (* ";" *)
    )
]

and last_match_arm = (
    outer_attribute_item list (* zero or more *)
  * match_pattern
  * Token.t (* "=>" *)
  * expression
  * Token.t (* "," *) option
)

and match_arm = (
    outer_attribute_item list (* zero or more *)
  * [ `Macro_invo of macro_invocation | `Match_pat of match_pattern ]
  * Token.t (* "=>" *)
  * [
        `Exp_COMMA of (expression * Token.t (* "," *))
      | `Choice_unsafe_blk of expression_ending_with_block
    ]
)

and match_block = (
    Token.t (* "{" *)
  * (match_arm list (* zero or more *) * last_match_arm) option
  * Token.t (* "}" *)
)

and match_pattern = (pattern * (Token.t (* "if" *) * expression) option)

and mod_block = (
    Token.t (* "{" *)
  * inner_attribute_item list (* zero or more *)
  * item list (* zero or more *)
  * Token.t (* "}" *)
)

and ordered_field_declaration_list = (
    Token.t (* "(" *)
  * (
        outer_attribute_item list (* zero or more *)
      * visibility_modifier option
      * type_
      * (
            Token.t (* "," *)
          * outer_attribute_item list (* zero or more *)
          * visibility_modifier option
          * type_
        )
          list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* ")" *)
)

and parameter = (
    Token.t (* "mut" *) option
  * [
        `Pat of pattern
      | `Self of Token.t (* "self" *)
      | `Choice_defa of reserved_identifier
    ]
  * Token.t (* ":" *)
  * type_
)

and parameters = (
    Token.t (* "(" *)
  * (
        outer_attribute_item option
      * anon_choice_param_2c23cdc
      * (
            Token.t (* "," *)
          * outer_attribute_item option
          * anon_choice_param_2c23cdc
        )
          list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* ")" *)
)

and path = [
    `Self of Token.t (* "self" *)
  | `Choice_u8 of anon_choice_u8_6dad923
  | `Meta of metavariable (*tok*)
  | `Super of Token.t (* "super" *)
  | `Crate of Token.t (* "crate" *)
  | `Id of identifier (*tok*)
  | `Scoped_id of scoped_identifier
]

and pattern = [
    `Lit_pat of literal_pattern
  | `Choice_u8 of anon_choice_u8_6dad923
  | `Id of identifier (*tok*)
  | `Scoped_id of scoped_identifier
  | `Tuple_pat of (
        Token.t (* "(" *)
      * anon_pat_rep_COMMA_pat_2a80f16 option
      * Token.t (* "," *) option
      * Token.t (* ")" *)
    )
  | `Tuple_struct_pat of (
        anon_choice_type_id_f1f5a37
      * Token.t (* "(" *)
      * anon_pat_rep_COMMA_pat_2a80f16 option
      * Token.t (* "," *) option
      * Token.t (* ")" *)
    )
  | `Struct_pat of (
        anon_choice_type_id_2c46bcf
      * Token.t (* "{" *)
      * (
            anon_choice_field_pat_8e757e8
          * (Token.t (* "," *) * anon_choice_field_pat_8e757e8)
              list (* zero or more *)
        )
          option
      * Token.t (* "," *) option
      * Token.t (* "}" *)
    )
  | `Ref_pat_a3d7f54 of (Token.t (* "ref" *) * pattern)
  | `Slice_pat of (
        Token.t (* "[" *)
      * anon_pat_rep_COMMA_pat_2a80f16 option
      * Token.t (* "," *) option
      * Token.t (* "]" *)
    )
  | `Capt_pat of (identifier (*tok*) * Token.t (* "@" *) * pattern)
  | `Ref_pat_dbbcf07 of (
        Token.t (* "&" *)
      * Token.t (* "mut" *) option
      * pattern
    )
  | `Rema_field_pat of Token.t (* ".." *)
  | `Mut_pat of (Token.t (* "mut" *) * pattern)
  | `Range_pat of (
        anon_choice_lit_pat_0884ef0
      * [
            `DOTDOTDOT of Token.t (* "..." *)
          | `DOTDOTEQ of Token.t (* "..=" *)
        ]
      * anon_choice_lit_pat_0884ef0
    )
  | `Or_pat of (pattern * Token.t (* "|" *) * pattern)
  | `Const_blk of const_block
  | `X__ of Token.t (* "_" *)
]

and pointer_type = (
    Token.t (* "*" *)
  * [ `Const of Token.t (* "const" *) | `Muta_spec of Token.t (* "mut" *) ]
  * type_
)

and qualified_type = (type_ * Token.t (* "as" *) * type_)

and range_expression = [
    `Exp_choice_DOTDOT_exp of (
        expression
      * [
            `DOTDOT of Token.t (* ".." *)
          | `DOTDOTDOT of Token.t (* "..." *)
          | `DOTDOTEQ of Token.t (* "..=" *)
        ]
      * expression
    )
  | `Exp_DOTDOT of (expression * Token.t (* ".." *))
  | `DOTDOT_exp of base_field_initializer
  | `DOTDOT of Token.t (* ".." *)
]

and reference_type = (
    Token.t (* "&" *)
  * lifetime option
  * Token.t (* "mut" *) option
  * type_
)

and return_expression = [
    `Ret_exp of (Token.t (* "return" *) * expression)
  | `Ret of Token.t (* "return" *)
]

and scoped_identifier = (
    [
        `Choice_self of path
      | `Brac_type of bracketed_type
      | `Gene_type_with_turb of generic_type_with_turbofish
    ]
      option
  * Token.t (* "::" *)
  * identifier (*tok*)
)

and scoped_type_identifier = (
    [
        `Choice_self of path
      | `Gene_type_with_turb of generic_type_with_turbofish
      | `Brac_type of bracketed_type
      | `Gene_type of generic_type
    ]
      option
  * Token.t (* "::" *)
  * identifier (*tok*)
)

and scoped_type_identifier_in_expression_position = (
    [
        `Choice_self of path
      | `Gene_type_with_turb of generic_type_with_turbofish
    ]
      option
  * Token.t (* "::" *)
  * identifier (*tok*)
)

and statement = [
    `Exp_stmt of expression_statement
  | `Let_decl of (
        Token.t (* "let" *)
      * Token.t (* "mut" *) option
      * pattern
      * (Token.t (* ":" *) * type_) option
      * (Token.t (* "=" *) * expression) option
      * Token.t (* ";" *)
    )
  | `Item of item
]

and trait_block = (
    Token.t (* "{" *)
  * trait_block_item list (* zero or more *)
  * Token.t (* "}" *)
)

and trait_block_item = (
    outer_attribute_item list (* zero or more *)
  * [
        `Const_item of const_item
      | `Func_sign_with_defa_item of function_signature_with_default_item
      | `Asso_type of associated_type
      | `Macro_invo of macro_invocation
    ]
)

and trait_bounds = (
    Token.t (* ":" *)
  * anon_choice_type_d689819
  * (Token.t (* "+" *) * anon_choice_type_d689819) list (* zero or more *)
)

and tuple_type = (
    Token.t (* "(" *)
  * type_
  * (Token.t (* "," *) * type_) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* ")" *)
)

and type_ = [
    `Abst_type of (Token.t (* "impl" *) * anon_choice_type_id_02b4436)
  | `Ref_type of reference_type
  | `Meta of metavariable (*tok*)
  | `Poin_type of pointer_type
  | `Gene_type of generic_type
  | `Scoped_type_id of scoped_type_identifier
  | `Tuple_type of tuple_type
  | `Unit_type of (Token.t (* "(" *) * Token.t (* ")" *))
  | `Array_type of (
        Token.t (* "[" *)
      * type_
      * (Token.t (* ";" *) * expression) option
      * Token.t (* "]" *)
    )
  | `Func_type of function_type
  | `Id of identifier (*tok*)
  | `Macro_invo of macro_invocation
  | `Empty_type of Token.t (* "!" *)
  | `Dyna_type of (Token.t (* "dyn" *) * anon_choice_type_id_02b4436)
  | `Boun_type of bounded_type
  | `Choice_u8 of anon_choice_u8_6dad923
]

and type_arguments = (
    tok_LT (*tok*)
  * anon_choice_type_39799c3
  * (Token.t (* "," *) * anon_choice_type_39799c3) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* ">" *)
)

and type_parameters = (
    Token.t (* "<" *)
  * anon_choice_life_859e88f
  * (Token.t (* "," *) * anon_choice_life_859e88f) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* ">" *)
)

and where_clause = (
    Token.t (* "where" *)
  * where_predicate
  * (Token.t (* "," *) * where_predicate) list (* zero or more *)
  * Token.t (* "," *) option
)

and where_predicate = (
    [
        `Life of lifetime
      | `Id of identifier (*tok*)
      | `Scoped_type_id of scoped_type_identifier
      | `Gene_type of generic_type
      | `Ref_type of reference_type
      | `Poin_type of pointer_type
      | `Tuple_type of tuple_type
      | `Higher_ranked_trait_bound of higher_ranked_trait_bound
      | `Choice_u8 of anon_choice_u8_6dad923
    ]
  * trait_bounds
)
[@@deriving sexp_of]

type source_file = [
    `Rep_inner_attr_item_rep_item of (
        inner_attribute_item list (* zero or more *)
      * item list (* zero or more *)
    )
  | `Semg_exp of (Token.t (* "__SEMGREP_EXPRESSION" *) * expression)
  | `Semg_stmt of (
        Token.t (* "__SEMGREP_STATEMENT" *)
      * statement list (* one or more *)
    )
]
[@@deriving sexp_of]

type variadic_parameter (* inlined *) = Token.t (* "..." *)
[@@deriving sexp_of]

type unit_expression (* inlined *) = (Token.t (* "(" *) * Token.t (* ")" *))
[@@deriving sexp_of]

type super (* inlined *) = Token.t (* "super" *)
[@@deriving sexp_of]

type empty_statement (* inlined *) = Token.t (* ";" *)
[@@deriving sexp_of]

type self (* inlined *) = Token.t (* "self" *)
[@@deriving sexp_of]

type remaining_field_pattern (* inlined *) = Token.t (* ".." *)
[@@deriving sexp_of]

type imm_tok_DQUOT (* inlined *) = Token.t (* "\"" *)
[@@deriving sexp_of]

type mutable_specifier (* inlined *) = Token.t (* "mut" *)
[@@deriving sexp_of]

type crate (* inlined *) = Token.t (* "crate" *)
[@@deriving sexp_of]

type ellipsis (* inlined *) = Token.t (* "..." *)
[@@deriving sexp_of]

type empty_type (* inlined *) = Token.t (* "!" *)
[@@deriving sexp_of]

type unit_type (* inlined *) = (Token.t (* "(" *) * Token.t (* ")" *))
[@@deriving sexp_of]

type field_identifier (* inlined *) = identifier (*tok*)
[@@deriving sexp_of]

type type_identifier (* inlined *) = identifier (*tok*)
[@@deriving sexp_of]

type comment (* inlined *) = [
    `Line_comm of line_comment (*tok*)
  | `Blk_comm of block_comment (*tok*)
]
[@@deriving sexp_of]

type negative_literal (* inlined *) = (
    Token.t (* "-" *)
  * [
        `Int_lit of integer_literal (*tok*)
      | `Float_lit of float_literal (*tok*)
    ]
)
[@@deriving sexp_of]

type token_binding_pattern (* inlined *) = (
    metavariable (*tok*) * Token.t (* ":" *) * fragment_specifier
)
[@@deriving sexp_of]

type extern_crate_declaration (* inlined *) = (
    Token.t (* "extern" *)
  * Token.t (* "crate" *)
  * identifier (*tok*)
  * (Token.t (* "as" *) * identifier (*tok*)) option
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type use_as_clause (* inlined *) = (
    simple_path * Token.t (* "as" *) * identifier (*tok*)
)
[@@deriving sexp_of]

type use_wildcard (* inlined *) = (
    (simple_path * Token.t (* "::" *)) option
  * Token.t (* "*" *)
)
[@@deriving sexp_of]

type self_parameter (* inlined *) = (
    Token.t (* "&" *) option
  * lifetime option
  * Token.t (* "mut" *) option
  * Token.t (* "self" *)
)
[@@deriving sexp_of]

type continue_expression (* inlined *) = (
    Token.t (* "continue" *)
  * loop_label option
)
[@@deriving sexp_of]

type scoped_use_list (* inlined *) = (
    simple_path option
  * Token.t (* "::" *)
  * use_list
)
[@@deriving sexp_of]

type token_repetition (* inlined *) = (
    Token.t (* "$" *)
  * Token.t (* "(" *)
  * tokens list (* zero or more *)
  * Token.t (* ")" *)
  * pat_1e84e62 (*tok*) option
  * anon_choice_PLUS_348fa54
)
[@@deriving sexp_of]

type token_repetition_pattern (* inlined *) = (
    Token.t (* "$" *)
  * Token.t (* "(" *)
  * token_pattern list (* zero or more *)
  * Token.t (* ")" *)
  * pat_1e84e62 (*tok*) option
  * anon_choice_PLUS_348fa54
)
[@@deriving sexp_of]

type use_declaration (* inlined *) = (
    Token.t (* "use" *) * use_clause * Token.t (* ";" *)
)
[@@deriving sexp_of]

type macro_definition (* inlined *) = (
    Token.t (* "macro_rules!" *)
  * identifier (*tok*)
  * [
        `LPAR_rep_macro_rule_SEMI_opt_macro_rule_RPAR_SEMI of (
            Token.t (* "(" *)
          * (macro_rule * Token.t (* ";" *)) list (* zero or more *)
          * macro_rule option
          * Token.t (* ")" *)
          * Token.t (* ";" *)
        )
      | `LCURL_rep_macro_rule_SEMI_opt_macro_rule_RCURL of (
            Token.t (* "{" *)
          * (macro_rule * Token.t (* ";" *)) list (* zero or more *)
          * macro_rule option
          * Token.t (* "}" *)
        )
    ]
)
[@@deriving sexp_of]

type shorthand_field_initializer (* inlined *) = (
    outer_attribute_item list (* zero or more *)
  * identifier (*tok*)
)
[@@deriving sexp_of]

type abstract_type (* inlined *) = (
    Token.t (* "impl" *) * anon_choice_type_id_02b4436
)
[@@deriving sexp_of]

type array_expression (* inlined *) = (
    Token.t (* "[" *)
  * outer_attribute_item list (* zero or more *)
  * [
        `Exp_SEMI_exp of (expression * Token.t (* ";" *) * expression)
      | `Opt_exp_rep_COMMA_exp_opt_COMMA of (
            (
                expression
              * (Token.t (* "," *) * expression) list (* zero or more *)
            )
              option
          * Token.t (* "," *) option
        )
    ]
  * Token.t (* "]" *)
)
[@@deriving sexp_of]

type array_type (* inlined *) = (
    Token.t (* "[" *)
  * type_
  * (Token.t (* ";" *) * expression) option
  * Token.t (* "]" *)
)
[@@deriving sexp_of]

type assignment_expression (* inlined *) = (
    expression * Token.t (* "=" *) * expression
)
[@@deriving sexp_of]

type async_block (* inlined *) = (
    Token.t (* "async" *)
  * Token.t (* "move" *) option
  * block
)
[@@deriving sexp_of]

type await_expression (* inlined *) = (
    expression * Token.t (* "." *) * Token.t (* "await" *)
)
[@@deriving sexp_of]

type break_expression (* inlined *) = (
    Token.t (* "break" *)
  * loop_label option
  * expression option
)
[@@deriving sexp_of]

type call_expression (* inlined *) = (expression * arguments)
[@@deriving sexp_of]

type captured_pattern (* inlined *) = (
    identifier (*tok*) * Token.t (* "@" *) * pattern
)
[@@deriving sexp_of]

type closure_expression (* inlined *) = (
    Token.t (* "move" *) option
  * closure_parameters
  * [
        `Opt_DASHGT_type_blk of ((Token.t (* "->" *) * type_) option * block)
      | `Exp of expression
    ]
)
[@@deriving sexp_of]

type compound_assignment_expr (* inlined *) = (
    expression
  * [
        `PLUSEQ of Token.t (* "+=" *)
      | `DASHEQ of Token.t (* "-=" *)
      | `STAREQ of Token.t (* "*=" *)
      | `SLASHEQ of Token.t (* "/=" *)
      | `PERCEQ of Token.t (* "%=" *)
      | `AMPEQ of Token.t (* "&=" *)
      | `BAREQ of Token.t (* "|=" *)
      | `HATEQ of Token.t (* "^=" *)
      | `LTLTEQ of Token.t (* "<<=" *)
      | `GTGTEQ of Token.t (* ">>=" *)
    ]
  * expression
)
[@@deriving sexp_of]

type const_parameter (* inlined *) = (
    Token.t (* "const" *) * identifier (*tok*) * Token.t (* ":" *) * type_
)
[@@deriving sexp_of]

type deep_ellipsis (* inlined *) = (
    Token.t (* "<..." *) * expression * Token.t (* "...>" *)
)
[@@deriving sexp_of]

type dynamic_type (* inlined *) = (
    Token.t (* "dyn" *) * anon_choice_type_id_02b4436
)
[@@deriving sexp_of]

type enum_item (* inlined *) = (
    Token.t (* "enum" *)
  * identifier (*tok*)
  * type_parameters option
  * where_clause option
  * enum_variant_list
)
[@@deriving sexp_of]

type field_initializer (* inlined *) = (
    outer_attribute_item list (* zero or more *)
  * identifier (*tok*)
  * Token.t (* ":" *)
  * expression
)
[@@deriving sexp_of]

type field_pattern (* inlined *) = (
    Token.t (* "ref" *) option
  * Token.t (* "mut" *) option
  * [
        `Id of identifier (*tok*)
      | `Id_COLON_pat of (identifier (*tok*) * Token.t (* ":" *) * pattern)
    ]
)
[@@deriving sexp_of]

type for_expression (* inlined *) = (
    (loop_label * Token.t (* ":" *)) option
  * Token.t (* "for" *)
  * pattern
  * Token.t (* "in" *)
  * expression
  * block
)
[@@deriving sexp_of]

type foreign_mod_item (* inlined *) = (
    extern_modifier
  * [ `SEMI of Token.t (* ";" *) | `Fore_mod_blk of foreign_mod_block ]
)
[@@deriving sexp_of]

type function_signature_item (* inlined *) = (
    function_modifiers option
  * Token.t (* "fn" *)
  * function_declaration
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type generic_function (* inlined *) = (
    [
        `Id of identifier (*tok*)
      | `Scoped_id of scoped_identifier
      | `Field_exp of field_expression
    ]
  * Token.t (* "::" *)
  * type_arguments
)
[@@deriving sexp_of]

type impl_item (* inlined *) = (
    Token.t (* "unsafe" *) option
  * Token.t (* "impl" *)
  * type_parameters option
  * (
        [
            `Id of identifier (*tok*)
          | `Scoped_type_id of scoped_type_identifier
          | `Gene_type of generic_type
        ]
      * Token.t (* "for" *)
    )
      option
  * type_
  * where_clause option
  * impl_block
)
[@@deriving sexp_of]

type index_expression (* inlined *) = (
    expression * Token.t (* "[" *) * expression * Token.t (* "]" *)
)
[@@deriving sexp_of]

type let_declaration (* inlined *) = (
    Token.t (* "let" *)
  * Token.t (* "mut" *) option
  * pattern
  * (Token.t (* ":" *) * type_) option
  * (Token.t (* "=" *) * expression) option
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type loop_expression (* inlined *) = (
    (loop_label * Token.t (* ":" *)) option
  * Token.t (* "loop" *)
  * block
)
[@@deriving sexp_of]

type match_expression (* inlined *) = (
    Token.t (* "match" *) * expression * match_block
)
[@@deriving sexp_of]

type mod_item (* inlined *) = (
    Token.t (* "mod" *)
  * identifier (*tok*)
  * [ `SEMI of Token.t (* ";" *) | `Mod_blk of mod_block ]
)
[@@deriving sexp_of]

type mut_pattern (* inlined *) = (Token.t (* "mut" *) * pattern)
[@@deriving sexp_of]

type optional_type_parameter (* inlined *) = (
    [
        `Id of identifier (*tok*)
      | `Cons_type_param of constrained_type_parameter
    ]
  * Token.t (* "=" *)
  * type_
)
[@@deriving sexp_of]

type or_pattern (* inlined *) = (pattern * Token.t (* "|" *) * pattern)
[@@deriving sexp_of]

type parenthesized_expression (* inlined *) = (
    Token.t (* "(" *) * expression * Token.t (* ")" *)
)
[@@deriving sexp_of]

type range_pattern (* inlined *) = (
    anon_choice_lit_pat_0884ef0
  * [ `DOTDOTDOT of Token.t (* "..." *) | `DOTDOTEQ of Token.t (* "..=" *) ]
  * anon_choice_lit_pat_0884ef0
)
[@@deriving sexp_of]

type ref_pattern (* inlined *) = (Token.t (* "ref" *) * pattern)
[@@deriving sexp_of]

type reference_expression (* inlined *) = (
    Token.t (* "&" *)
  * Token.t (* "mut" *) option
  * expression
)
[@@deriving sexp_of]

type reference_pattern (* inlined *) = (
    Token.t (* "&" *)
  * Token.t (* "mut" *) option
  * pattern
)
[@@deriving sexp_of]

type removed_trait_bound (* inlined *) = (Token.t (* "?" *) * type_)
[@@deriving sexp_of]

type slice_pattern (* inlined *) = (
    Token.t (* "[" *)
  * anon_pat_rep_COMMA_pat_2a80f16 option
  * Token.t (* "," *) option
  * Token.t (* "]" *)
)
[@@deriving sexp_of]

type static_item (* inlined *) = (
    Token.t (* "static" *)
  * Token.t (* "ref" *) option
  * Token.t (* "mut" *) option
  * identifier (*tok*)
  * Token.t (* ":" *)
  * type_
  * (Token.t (* "=" *) * expression) option
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type struct_expression (* inlined *) = (
    [
        `Id of identifier (*tok*)
      | `Scoped_type_id_in_exp_posi of
          scoped_type_identifier_in_expression_position
      | `Gene_type_with_turb of generic_type_with_turbofish
    ]
  * field_initializer_list
)
[@@deriving sexp_of]

type struct_item (* inlined *) = (
    Token.t (* "struct" *)
  * identifier (*tok*)
  * type_parameters option
  * [
        `Opt_where_clause_field_decl_list of (
            where_clause option
          * field_declaration_list
        )
      | `Orde_field_decl_list_opt_where_clause_SEMI of (
            ordered_field_declaration_list
          * where_clause option
          * Token.t (* ";" *)
        )
      | `SEMI of Token.t (* ";" *)
    ]
)
[@@deriving sexp_of]

type struct_pattern (* inlined *) = (
    anon_choice_type_id_2c46bcf
  * Token.t (* "{" *)
  * (
        anon_choice_field_pat_8e757e8
      * (Token.t (* "," *) * anon_choice_field_pat_8e757e8)
          list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)
[@@deriving sexp_of]

type trait_item (* inlined *) = (
    Token.t (* "unsafe" *) option
  * Token.t (* "trait" *)
  * identifier (*tok*)
  * type_parameters option
  * trait_bounds option
  * where_clause option
  * trait_block
)
[@@deriving sexp_of]

type try_expression (* inlined *) = (expression * Token.t (* "?" *))
[@@deriving sexp_of]

type tuple_expression (* inlined *) = (
    Token.t (* "(" *)
  * outer_attribute_item list (* zero or more *)
  * expression
  * Token.t (* "," *)
  * (expression * Token.t (* "," *)) list (* zero or more *)
  * expression option
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type tuple_pattern (* inlined *) = (
    Token.t (* "(" *)
  * anon_pat_rep_COMMA_pat_2a80f16 option
  * Token.t (* "," *) option
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type tuple_struct_pattern (* inlined *) = (
    anon_choice_type_id_f1f5a37
  * Token.t (* "(" *)
  * anon_pat_rep_COMMA_pat_2a80f16 option
  * Token.t (* "," *) option
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type type_binding (* inlined *) = (
    identifier (*tok*) * Token.t (* "=" *) * type_
)
[@@deriving sexp_of]

type type_cast_expression (* inlined *) = (
    expression * Token.t (* "as" *) * type_
)
[@@deriving sexp_of]

type type_item (* inlined *) = (
    Token.t (* "type" *)
  * identifier (*tok*)
  * type_parameters option
  * Token.t (* "=" *)
  * type_
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type unary_expression (* inlined *) = (
    [
        `DASH of Token.t (* "-" *)
      | `STAR of Token.t (* "*" *)
      | `BANG of Token.t (* "!" *)
    ]
  * expression
)
[@@deriving sexp_of]

type union_item (* inlined *) = (
    Token.t (* "union" *)
  * identifier (*tok*)
  * type_parameters option
  * where_clause option
  * field_declaration_list
)
[@@deriving sexp_of]

type unsafe_block (* inlined *) = (Token.t (* "unsafe" *) * block)
[@@deriving sexp_of]

type while_expression (* inlined *) = (
    (loop_label * Token.t (* ":" *)) option
  * Token.t (* "while" *)
  * expression
  * block
)
[@@deriving sexp_of]

type while_let_expression (* inlined *) = (
    (loop_label * Token.t (* ":" *)) option
  * Token.t (* "while" *)
  * Token.t (* "let" *)
  * pattern
  * Token.t (* "=" *)
  * expression
  * block
)
[@@deriving sexp_of]

type semgrep_statement (* inlined *) = (
    Token.t (* "__SEMGREP_STATEMENT" *)
  * statement list (* one or more *)
)
[@@deriving sexp_of]

type semgrep_expression (* inlined *) = (
    Token.t (* "__SEMGREP_EXPRESSION" *) * expression
)
[@@deriving sexp_of]

let dump_tree root =
  sexp_of_source_file root
  |> Print_sexp.to_stdout
